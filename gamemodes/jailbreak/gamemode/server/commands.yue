Jailbreak = Jailbreak

:HasWarden, :Emotion, :GameInProgress = Jailbreak
NOTIFY_ERROR = NOTIFY_ERROR
CHAN_STATIC = CHAN_STATIC
tonumber = tonumber
:Add = concommand
CurTime = CurTime
Entity = Entity
:random = math
:Run = hook

do

    :ChangeTeam = Jailbreak

    Add "changeteam", ( _, args ) =>
        teamID = args[ 1 ]
        if teamID
            teamID = tonumber( teamID ) or 0
        else
            teamID = 0

        ChangeTeam( @, teamID )

do

    :IsRoundRunning, :SetShockCollars, :IsShockCollarsActive = Jailbreak

    Add "jb_warden", ( _, args ) =>
        unless @ and @IsValid!
            return

        unless IsRoundRunning! and @IsGuard! and @Alive!
            @SendNotify( "#jb.error.warden-failure", NOTIFY_ERROR, 10 )
            return

        if ( @WardenDelay or 0 ) > CurTime!
            @SendNotify( "#jb.please-wait", NOTIFY_ERROR, 3 )
            return

        if @IsWarden!
            @WardenDelay = CurTime! + 5
            @SetWarden( false )
            return

        if HasWarden!
            @SendNotify( "#jb.error.warden-exists", NOTIFY_ERROR, 10 )
            return

        @WardenDelay = CurTime! + 3
        @SetWarden( true )

    Add "jb_shock_collars", ( _, args ) =>
        unless @ and @IsValid!
            return

        unless IsRoundRunning! and @Alive! and @IsWarden!
            @SendNotify( "#jb.error.cant-do-that", NOTIFY_ERROR, 10 )
            return

        if ( @ShockCollarsDelay or 0 ) > CurTime!
            @SendNotify( "#jb.please-wait", NOTIFY_ERROR, 3 )
            return

        requested = args[ 1 ]
        if requested ~= nil and #requested ~= 0
            SetShockCollars( requested == "1" )
        else
            SetShockCollars( not IsShockCollarsActive! )

        @ShockCollarsDelay = CurTime! + 3

do

    :SetRoundState, :SetRoundTime = Jailbreak
    :Clamp = math

    Add "jb_force_round", ( _, args ) =>
        if @ and @IsValid! and not @IsSuperAdmin!
            return

        index = args[ 1 ]
        if index
            SetRoundState( Clamp( tonumber( index ) or 0, 0, 3 ) )
        else
            SetRoundState( 0 )
            SetRoundTime( 0 )

Add "jb_respawn", ( _, args ) =>
    if @ and @IsValid! and not @IsSuperAdmin!
        return

    if #args == 0
        @Spawn!
        return

    index = tonumber( args[ 1 ] )
    unless index
        return

    ply = Entity( index )
    if ply\IsValid!
        ply\Spawn!

Add "jb_move_player", ( _, args ) =>
    if @ and @IsValid! and not @IsSuperAdmin!
        return

    index = tonumber( args[ 1 ] )
    unless index
        return

    ply = Entity( index )
    if ply and ply\IsValid!
        if ply\Alive!
            ply\Kill!

        teamID = tonumber( args[ 2 ] )
        if teamID
            ply\SetTeam( teamID )

        if args[ 3 ]
            ply\Spawn!

Add "jb_kick_player", ( _, args ) =>
    if @ and @IsValid! and not @IsSuperAdmin!
        return

    index = tonumber( args[ 1 ] )
    unless index
        return

    ply = Entity( index )
    if ply\IsValid!
        reason = args[ 2 ]
        if reason ~= nil
            ply\Kick( reason )
        else
            ply\Kick!

do

    :IsValidModel = util

    dropWeapon = =>
        unless @Alive!
            return

        droppedWeapon = @GetActiveWeapon!
        unless droppedWeapon and droppedWeapon\IsValid!
            return

        model = droppedWeapon\GetWeaponWorldModel!
        unless model and #model ~= 0 and IsValidModel( model )
            return

        traceResult, isPlayer = @GetEyeTrace!, false
        if traceResult.Hit
            entity = traceResult.Entity
            if entity\IsValid! and entity\IsPlayer! and entity\Alive!
                isPlayer = true

        @DropWeapon( droppedWeapon )

        unless droppedWeapon\IsInWorld!
            @PickupWeapon( droppedWeapon )
            @SelectWeapon( droppedWeapon\GetClass! )
            return

        if isPlayer
            @DoAnimationEvent( ACT_GMOD_GESTURE_ITEM_GIVE )
        else
            @DoAnimationEvent( ACT_GMOD_GESTURE_ITEM_DROP )

        maxWeight, nextWeapon = nil, nil
        for weapon in *@GetWeapons!
            weight = weapon\GetWeight!

            if not maxWeight or maxWeight <= weight
                nextWeapon = weapon
                maxWeight = weight

        unless nextWeapon and nextWeapon\IsValid!
            return

        @SelectWeapon( nextWeapon\GetClass! )

    Add "drop", dropWeapon
    Jailbreak.SetChatCommand "drop", dropWeapon, "#jb.chat.command.drop"
    Jailbreak.SetChatCommand "dropweapon", dropWeapon, "#jb.chat.command.drop"

do

    util.AddNetworkString( "Jailbreak::Markers" )

    :Markers, :VoiceChatMinDistance, :MarkersLifetime, :MarkersCount, :GetWeaponName = Jailbreak
    :Start, :WriteEntity, :WriteBool, :WriteVector, :Send, :Broadcast = net
    :white = Jailbreak.Colors
    EmitSound = EmitSound
    :TraceLine = util
    :abs = math

    trace = {
        mask: MASK_SHOT
    }

    Add "marker", =>
        unless Markers\GetBool! and @ and @IsValid! and @Alive!
            return

        if @NextMarker and CurTime! < @NextMarker
            return

        isWarden, isPrisoner = @IsWarden!, @IsPrisoner!
        if not isWarden and @IsGuard! and not HasWarden!
            isWarden = true

        unless isWarden or isPrisoner
            @SendNotify( "#jb.error.cant-do-that", NOTIFY_ERROR, 10 )
            return

        distance = 0
        if isWarden
            distance = 32768
        elseif isPrisoner
            distance = 4096

        @LagCompensation( true )

        trace.filter = @

        start = @EyePos!
        trace.start = start
        trace.endpos = start + @GetAimVector! * distance

        traceResult = TraceLine( trace )

        @LagCompensation( false )

        unless traceResult.Hit
            return

        @NextMarker = CurTime! + ( MarkersLifetime\GetInt! / MarkersCount\GetInt! )

        entity = traceResult.Entity
        isValid = entity and entity\IsValid!

        Start( "Jailbreak::Markers" )
        WriteEntity( @ )
        WriteBool( isValid )

        origin = nil
        if isValid
            WriteEntity( entity )
            origin = entity\WorldToLocal( traceResult.HitPos )
        else
            origin = traceResult.HitPos

        WriteVector( origin )

        if isWarden
            Broadcast!

            rf = RecipientFilter!
            rf\AddPAS( origin )

            if isValid
                entity\EmitSound( "buttons/button" .. random( 14, 19 ) .. ".wav", 75, random( 80, 120 ), 1, CHAN_STATIC, 0, 1, rf )
            else
                EmitSound( "buttons/button" .. random( 14, 19 ) .. ".wav", origin, 0, CHAN_STATIC, 1, 75, 0, random( 80, 120 ), 1, rf )

        elseif isPrisoner
            rf = RecipientFilter!

            hasSender = false
            for ply in *@GetNearPlayers( VoiceChatMinDistance\GetInt!, true )
                if ply == @
                    hasSender = true

                rf\AddPlayer( ply )

            unless hasSender
                rf\AddPlayer( @ )

            Send( rf )

            if isValid
                entity\EmitSound( "buttons/button" .. random( 14, 19 ) .. ".wav", 75, random( 80, 120 ), 1, CHAN_STATIC, 0, 1, rf )
            else
                EmitSound( "buttons/button" .. random( 14, 19 ) .. ".wav", origin, 0, CHAN_STATIC, 1, 75, 0, random( 80, 120 ), 1, rf )

        if isValid
            @AnimRestartNetworkedGesture( GESTURE_SLOT_CUSTOM, ACT_SIGNAL_GROUP, true )
        else
            @AnimRestartNetworkedGesture( GESTURE_SLOT_CUSTOM, ACT_SIGNAL_FORWARD, true )

        if entity\IsValid!
            if entity\IsPlayer!
                Emotion( @, "#jb.chat.pointed-at \"", entity\GetModelColor!, entity\Nick!, white, "\"." )
            elseif entity\IsPlayerRagdoll!
                Emotion( @, "#jb.chat.pointed-at \"", entity\GetModelColor!, entity\GetRagdollOwnerNickname!, white, "\"." )
            elseif entity\IsWeapon!
                Emotion( @, "#jb.chat.pointed-at \"" .. GetWeaponName( entity ) .. "\"." )
            else
                Emotion( @, "#jb.chat.pointed-at \"#jb." .. entity\GetClass! .. "\"." )

        elseif traceResult.HitSky
            Emotion( @, "#jb.chat.pointed-at \"#jb.sky\"." )

        else

            dir = traceResult.HitNormal
            if abs( dir[ 1 ] ) > 0.5 or abs( dir[ 2 ] ) > 0.5
                Emotion( @, "#jb.chat.pointed-at \"#jb.wall\"." )
            elseif dir[ 3 ] > 0.5
                Emotion( @, "#jb.chat.pointed-at \"#jb.floor\"." )
            else
                Emotion( @, "#jb.chat.pointed-at \"#jb.ceiling\"." )

Add "jb_reload_localization", =>
    if @ and @IsValid! and not @IsListenServerHost!
        return

    Jailbreak.ReloadLocalization!

do

    :ShopItems, :TakeWardenCoins, :CanWardenAfford = Jailbreak
    NOTIFY_GENERIC = NOTIFY_GENERIC

    Add "jb_buy", ( _, args ) =>
        unless GameInProgress! and @ and @IsValid! and @Alive! and @IsWarden!
            return

        item = ShopItems[ args[ 1 ] ]
        unless item
            return

        unless CanWardenAfford( item.price )
            @SendNotify( "#jb.shop.not-enough-coins", NOTIFY_ERROR, 5 )
            return

        if Run( "PlayerCanBuyItem", @, item ) == false
            @SendNotify( "#jb.error.cant-do-that", NOTIFY_ERROR, 5 )
            return

        unless item.action
            return

        if item.action( @, item ) == false
            @SendNotify( "#jb.error.cant-do-that", NOTIFY_ERROR, 5 )
            return

        TakeWardenCoins( item.price )

        @EmitSound( "ambient/levels/labs/coinslot1.wav", 75, random( 80, 120 ), 1, CHAN_STATIC, 0, 1 )
        @SendNotify( "#jb.shop.you-bought \"" .. item.title .. "\"", NOTIFY_GENERIC, 5 )
        Emotion( @, "#jb.chat.bought \"" .. item.title .. "\"." )
        Run( "PlayerBoughtItem", @, item )

do

    Add "jb_fake_death", =>
        unless @ and @IsValid!
            return

        unless GameInProgress! and @Alive! and util.IsInWorld( @EyePos! )
            @SendNotify( "#jb.error.cant-do-that", NOTIFY_ERROR, 5 )
            return

        ragdoll = @GetRagdollEntity!
        if ragdoll and ragdoll\IsValid! and ragdoll\GetNW2Bool( "fake-death" )
            Run( "PlayerSpawnFromRagdoll", @, ragdoll )
            @SetNotSolid( false )
            @SetNoDraw( false )
            @UnSpectate!
            ragdoll\Remove!
            return

        ragdoll = @CreateRagdoll( true )
        if ragdoll and ragdoll\IsValid!
            ragdoll\SetNW2Bool( "fake-death", true )
            @Spectate( OBS_MODE_CHASE )
            @SpectateEntity( ragdoll )
            @SetNotSolid( true )
            @SetNoDraw( true )

    hook.Add "EntityTakeDamage", "Jailbreak::FakeDeath", ( damageInfo ) =>
        unless @IsPlayerRagdoll! and @GetNW2Bool( "fake-death" )
            return

        ply = @GetRagdollOwner!
        if ply and ply\IsValid! and ply\Alive!
            ply\TakeDamageInfo( damageInfo )

            if ply\Alive!
                @Alive = true
            else
                @SetNW2Bool( "fake-death", false )
                @Alive = false

            return true

    hook.Add "PlayerCanCreateRagdoll", "Jailbreak::FakeDeath", =>
        ragdoll = @GetRagdollEntity!
        if ragdoll and ragdoll\IsValid! and ragdoll\GetNW2Bool( "fake-death" )
            return false

do

    Add "jb_paint_entity_apply", ( _, args ) =>
        unless @ and @IsValid!
            return

        unless @Alive!
            @SendNotify( "#jb.error.cant-do-that", NOTIFY_ERROR, 5 )
            return

        entity = Entity( tonumber( args[ 1 ] or "0" ) or 0 )
        unless entity and entity\IsValid! and entity\IsPaintCan!
            return

        if entity\GetPos!\Distance( @GetPos! ) > 72
            return

        color = string.Split( args[ 2 ] or "0 0 0", " " )
        @SetColor( Color( color[ 1 ], color[ 2 ], color[ 3 ] ) )

    hook.Add "PlayerUsedEntity", "Jailbreak::PaintCan", ( entity ) =>
        if entity\IsPaintCan!
            @ConCommand( "jb_paint_entity " .. entity\EntIndex! )

    hook.Add "AllowPlayerPickup", "Jailbreak::PaintCan", ( entity ) =>
        if entity\IsPaintCan!
            return false
