NOTIFY_UNDO = NOTIFY_UNDO
Jailbreak = Jailbreak

:IsInWorld, :IsValidModel, :TraceLine = util
vector_origin = vector_origin
:FixModelPath = Jailbreak
:Simple = timer
:Create = ents
:Run = hook

OBS_MODE_ROAMING = OBS_MODE_ROAMING
OBS_MODE_CHASE = OBS_MODE_CHASE
NULL = NULL

PLAYER = FindMetaTable( "Player" )
PLAYER.ChangeTeam = Jailbreak.ChangeTeam

-- Flashlight
PLAYER.HasFlashlight = PLAYER.CanUseFlashlight

PLAYER.GiveFlashlight = ( silent ) =>
    if @HasFlashlight!
        return

    if @FlashlightIsOn!
        @Flashlight( false )

    @AllowFlashlight( true )

    unless @IsBot! or silent
        @SendPickupNotify( "jb.flashlight" )

PLAYER.TakeFlashlight = ( silent ) =>
    unless @HasFlashlight!
        return

    if @FlashlightIsOn!
        @Flashlight( false )

    @AllowFlashlight( false )

    unless @IsBot! or silent
        @SendNotify( "#jb.flashlight.lost", NOTIFY_UNDO, 5 )

-- Security keys
PLAYER.GiveSecurityKeys = ( silent ) =>
    if @HasSecurityKeys!
        return

    @SetNW2Bool( "security-keys", true )

    unless @IsBot! or silent
        @SendPickupNotify( "jb.security.keys" )

PLAYER.TakeSecurityKeys = ( silent ) =>
    unless @HasSecurityKeys!
        return

    @SetNW2Bool( "security-keys", false )

    unless @IsBot! or silent
        @SendNotify( "#jb.security.keys.lost", NOTIFY_UNDO, 5 )

-- Security radio
PLAYER.GiveSecurityRadio = ( silent ) =>
    if @HasSecurityRadio!
        return

    @SetNW2Bool( "security-radio", true )

    unless @IsBot! or silent
        @SendPickupNotify( "jb.walkie-talkie" )

PLAYER.TakeSecurityRadio = ( silent ) =>
    unless @HasSecurityRadio!
        return

    @SetNW2Bool( "security-radio", false )

    unless @IsBot! or silent
        @SendNotify( "#jb.walkie-talkie.lost", NOTIFY_UNDO, 5 )

-- Shock collar
PLAYER.GiveShockCollar = ( silent ) =>
    if @HasShockCollar!
        return

    @SetNW2Bool( "shock-collar", true )
    @SetShockCollar( false, true )

    unless @IsBot! or silent
        @SendPickupNotify( "jb.shock-collar" )

PLAYER.TakeShockCollar = ( silent ) =>
    unless @HasShockCollar!
        return

    @SetShockCollar( false, true )
    @SetNW2Bool( "shock-collar", false )

    unless @IsBot! or silent
        @SendNotify( "#jb.shock-collar.lost", NOTIFY_UNDO, 5 )

PLAYER.SetShockCollar = ( bool, silent ) =>
    if bool == @ShockCollarIsEnabled!
        return

    @SetNW2Bool( "shock-collar-enabled", bool )

    if silent
        return

    Run( "ShockCollarToggled", @, bool )

-- Warden
PLAYER.SetWarden = ( bool, silent ) =>
    if bool == @IsWarden!
        return

    @SetNW2Bool( "is-warden", bool )

    if silent
        return

    Run( "WardenChanged", @, bool )

hook.Add "PostPlayerDeath", "Jailbreak::WardenDeath", =>
    @SetWarden( false )

-- Allows player use of flight
PLAYER.AllowFlight = ( bool ) =>
    @SetNW2Bool( "flight-allowed", bool )

hook.Add "PostPlayerDeath", "Jailbreak::DisallowFlight", =>
    @AllowFlight( false )

do

    :PlayerSlowWalkSpeed, :PlayerWalkSpeed, :PlayerRunSpeed, :PlayerJumpPower = Jailbreak

    PLAYER.SetupMovement = =>
        @SetSlowWalkSpeed( PlayerSlowWalkSpeed\GetInt! )
        @SetWalkSpeed( PlayerWalkSpeed\GetInt! )
        @SetRunSpeed( PlayerRunSpeed\GetInt! )
        @SetJumpPower( PlayerJumpPower\GetInt! )
        Run( "SetupPlayerMovement", @ )

do

    :Start, :WriteUInt, :WriteTable, :WriteString, :WriteBool, :WriteEntity, :Send = net

    PLAYER.PlaySound = ( soundPath ) =>
        Start( "Jailbreak::Networking" )
        WriteUInt( 3, 4 )
        WriteString( soundPath )
        Send( @ )

    PLAYER.SendPickupNotify = ( itemName ) =>
        Start( "Jailbreak::Networking" )
        WriteUInt( 1, 4 )
        WriteString( itemName )
        Send( @ )

    do

        util.AddNetworkString( "Jailbreak::Shop" )
        :ShopItems = Jailbreak

        PLAYER.SendShopItems = =>
            Start( "Jailbreak::Shop" )

            length = #ShopItems
            WriteUInt( length, 16 )

            for index = 1, length
                item = ShopItems[ index ]
                if item ~= nil
                    WriteString( item.name )
                    WriteString( item.model )
                    WriteUInt( item.price, 16 )
                    WriteUInt( item.skin, 8 )
                    WriteString( item.bodygroups )

            Send( @ )

    PLAYER.ResetToggles = =>
        Start( "Jailbreak::Networking" )
        WriteUInt( 5, 4 )
        Send( @ )

    do

        RecipientFilter = RecipientFilter
        isfunction = isfunction

        PLAYER.AnimRestartNetworkedGesture = ( slot, activity, autokill, finished, frac ) =>
            sequenceID = @SelectWeightedSequence( activity )
            if sequenceID < 0
                return

            rf = RecipientFilter!
            rf\AddPVS( @WorldSpaceCenter! )
            if rf\GetCount! > 0
                Start( "Jailbreak::Networking" )
                WriteUInt( 4, 4 )
                WriteEntity( @ )
                WriteUInt( slot, 3 )
                WriteUInt( activity, 11 )
                WriteBool( autokill or false )
                Send( rf )

            if isfunction( finished )
                duration = @SequenceDuration( sequenceID )
                Simple duration - duration * ( frac or 0 ), ->
                    if @IsValid!
                        finished( @ )

            @AnimRestartGesture( slot, activity, autokill )

    do

        sounds = {
            [ NOTIFY_GENERIC ]: "buttons/button9.wav"
            [ NOTIFY_ERROR ]: "player/suit_denydevice.wav"
            [ NOTIFY_HINT ]: "buttons/button24.wav"
            [ NOTIFY_CLEANUP ]: "buttons/button6.wav"
            [ NOTIFY_UNDO ]: "buttons/button9.wav"
        }

        PLAYER.SendNotify = ( text, typeID, length, ... ) =>
            Start( "Jailbreak::Networking" )
            WriteUInt( 2, 4 )
            WriteString( text )
            WriteTable( { ... }, true )
            WriteUInt( typeID, 3 )
            WriteUInt( length, 16 )
            Send( @ )

            soundPath = sounds[ typeID ]
            if soundPath ~= nil
                @PlaySound( soundPath )

PLAYER.ObserveEntity = ( entity ) =>
    if @Alive!
        @UnSpectate!
        return

    unless entity and entity\IsValid!
        if @GetObserverMode! ~= OBS_MODE_ROAMING
            @Spectate( OBS_MODE_ROAMING )

        return

    if @GetObserverTarget! ~= entity
        @SpectateEntity( entity )

    if @GetObserverMode! ~= OBS_MODE_CHASE
        @Spectate( OBS_MODE_CHASE )

do

    :ObserveTargets = Jailbreak

    PLAYER.MoveObserveIndex = ( move, players ) =>
        if @Alive! or #ObserveTargets == 0
            return

        index, length = ( @LastSpectatedIndex or 0 ) + move, #ObserveTargets
        if index > length
            index = 1
        elseif index < 1
            index = length

        entity = ObserveTargets[ index ]
        if entity\IsPlayer! or entity\IsRagdoll!
            @ObserveEntity( entity )
        else

            if @GetObserverMode! ~= OBS_MODE_ROAMING
                @Spectate( OBS_MODE_ROAMING )

            angles = entity\GetAngles!
            angles[ 3 ] = 0

            @SetEyeAngles( angles )
            @SetPos( entity\GetPos! )

        @LastSpectatedIndex = index

PLAYER.UsingMegaphone = =>
    return @IsWarden! and @GetInfo( "jb_megaphone" ) == "1"

do

    color = Color( 255, 255, 255, 240 )
    CurTime = CurTime
    :IN = SCREENFADE

    PLAYER.Shock = ( time ) =>
        @SetNW2Int( "shock-time", CurTime! + ( time or 3 ) )
        @ScreenFade( IN, color, 0.25, time or 3 )

do

    WeaponHandlers = WeaponHandlers or {}

    PLAYER.Give = ( className, noAmmo, force ) =>
        handler = WeaponHandlers[ className ]
        if handler
            className = handler.Alternative or className

        if @HasWeapon( className )
            return NULL

        weapon = Create( className )
        unless weapon and weapon\IsValid!
            return NULL

        weapon\SetAngles( @GetAngles! )
        weapon\SetPos( @GetPos! )

        weapon\Spawn!
        weapon\Activate!

        unless weapon\IsWeapon!
            return weapon

        if not force and Run( "PlayerCanPickupWeapon", @, weapon ) == false
            weapon\Remove!
            return NULL

        if noAmmo
            weapon\SetClip1( 0 )
            weapon\SetClip2( 0 )

        @PickupWeapon( weapon, false )
        return weapon

PLAYER.SetMutedByWarden = ( bool ) =>
    @SetNW2Bool( "warden-mute", bool )

PLAYER.RemoveRagdoll = =>
    ragdoll = @GetRagdollEntity!
    if ragdoll\IsValid!
        ragdoll\Remove!

do

    :ceil = math

    PLAYER.Heal = ( frac ) =>
        amount = ceil( @GetMaxHealth! * ( frac or 1 ) )
        @SetHealth( amount )
        return amount

do

    :max = math

    PLAYER.AddHealth = ( amount ) =>
        amount = max( @GetHealth! + amount, @GetMaxHealth! )
        @SetHealth( amount )
        return amount

    PLAYER.TakeHealth = ( amount ) =>
        amount = max( 0, @GetHealth! - amount )
        @SetHealth( amount )
        if amount == 0
            @Kill!

        return amount

PLAYER.CreateClientsideRagdoll = PLAYER.CreateClientsideRagdoll or PLAYER.CreateRagdoll
COLLISION_GROUP_PASSABLE_DOOR = COLLISION_GROUP_PASSABLE_DOOR

do

    :RagdollRemove, :RagdollHealth, :GetRoundState = Jailbreak
    ROUND_PREPARING = ROUND_PREPARING
    ROUND_FINISHED = ROUND_FINISHED

    trace = {}

    PLAYER.CreateRagdoll = ( putItems ) =>
        roundState = GetRoundState!
        if roundState == ROUND_PREPARING or roundState == ROUND_FINISHED
            return NULL

        if Run( "PlayerCanCreateRagdoll", @, putItems ) == false
            return NULL

        if RagdollRemove\GetBool!
            @RemoveRagdoll!

        spawnOrigin = @GetPos!
        unless IsInWorld( spawnOrigin )
            return NULL

        modelPath = @GetModel!
        unless modelPath
            return NULL

        modelPath = FixModelPath( modelPath )
        unless IsValidModel( modelPath )
            return NULL

        ragdoll = Create( @GetBoneCount! > 1 and "prop_ragdoll" or "prop_physics" )
        ragdoll\SetAngles( @GetAngles! )
        ragdoll\SetModel( modelPath )
        ragdoll\SetPos( spawnOrigin )
        ragdoll\Spawn!

        ragdoll\SetHealth( RagdollHealth\GetInt! )
        ragdoll\SetMaxHealth( ragdoll\Health! )
        ragdoll\SetTeam( @Team! )

        if @Alive!
            ragdoll\SetNW2Bool( "alive", true )
            ragdoll.MaxArmor = @GetMaxArmor!
            ragdoll.Armor = @Armor!

            angles = @EyeAngles!
            angles[ 1 ], angles[ 3 ] = 0, 0
            ragdoll.PlayerAngles = angles

        for bodygroup in *@GetBodyGroups!
            ragdoll\SetBodygroup( bodygroup.id, @GetBodygroup( bodygroup.id ) )

        ragdoll\SetFlexScale( @GetFlexScale! )
        for flexID = 0, @GetFlexNum!
            ragdoll\SetFlexWeight( flexID, @GetFlexWeight( flexID ) )

        ragdoll\SetPlayerColor( @GetPlayerColor! )
        ragdoll\SetMaterial( @GetMaterial! )
        ragdoll\SetColor( @GetColor! )
        ragdoll\SetSkin( @GetSkin! )

        for index = 1, #@GetMaterials!
            materialPath = @GetSubMaterial( index )
            if materialPath ~= ""
                ragdoll\SetSubMaterial( index, materialPath )

        ragdoll\SetCollisionGroup( COLLISION_GROUP_PASSABLE_DOOR )
        ragdoll\SetNW2Bool( "is-player-ragdoll", true )
        ragdoll\SetNW2Entity( "ragdoll-owner", @ )
        @SetNW2Entity( "player-ragdoll", ragdoll )

        unless @IsBot!
            ragdoll\SetNW2String( "owner-steamid64", @SteamID64! )
        ragdoll\SetNW2String( "owner-nickname", @Nick! )

        for bone = 0, @GetBoneCount! - 1
            ragdoll\ManipulateBonePosition( bone, @GetManipulateBonePosition( bone ) )
            ragdoll\ManipulateBoneAngles( bone, @GetManipulateBoneAngles( bone ) )
            ragdoll\ManipulateBoneJiggle( bone, @GetManipulateBoneJiggle( bone ) )
            ragdoll\ManipulateBoneScale( bone, @GetManipulateBoneScale( bone ) )

        if ragdoll\IsRagdoll!
            velocity = @LastVelocity
            for physNum = 0, ragdoll\GetPhysicsObjectCount! - 1 do
                phys = ragdoll\GetPhysicsObjectNum( physNum )
                unless phys and phys\IsValid!
                    continue

                bone = ragdoll\TranslatePhysBoneToBone( physNum )
                if bone < 0
                    continue

                origin, angles = @GetBonePosition( bone )
                if origin ~= nil
                    phys\SetAngles( angles )
                    unless IsInWorld( origin )
                        continue

                    trace.start = origin
                    trace.endpos = origin
                    trace.filter = { ragdoll, @ }

                    if TraceLine( trace ).Hit
                        continue

                    phys\SetPos( origin )

                phys\SetVelocity( velocity )
                phys\Wake!

        else

            phys = ragdoll\GetPhysicsObject!
            if phys and phys\IsValid!
                phys\SetVelocity( @LastVelocity )
                phys\Wake!

        if @IsOnFire!
            ragdoll\Ignite( 5, 64 )
            @Extinguish!

        Run( "PlayerRagdollCreated", @, ragdoll )

        if putItems ~= false
            ragdoll.HasSecurityRadio = @HasSecurityRadio!
            @TakeSecurityRadio!

            ragdoll.HasSecurityKeys = @HasSecurityKeys!
            @TakeSecurityKeys!

            ragdoll.HasFlashlight = @CanUseFlashlight!
            @TakeFlashlight!

            ragdoll.HasShockCollar = @HasShockCollar!
            @TakeShockCollar!

            weapons, length = {}, 0
            for weapon in *@GetWeapons!
                if #weapon\GetWeaponWorldModel! == 0
                    continue

                @DropWeapon( weapon )
                unless weapon\IsValid!
                    continue

                weapon.PickupForbidden = true
                weapon\SetPos( spawnOrigin )
                weapon\SetParent( ragdoll )
                weapon\SetNotSolid( true )
                weapon\SetNoDraw( true )

                length += 1
                weapons[ length ] = weapon

            if length ~= 0
                ragdoll.Weapons = weapons

            ragdoll.Ammo = @GetAmmo!
            @RemoveAllAmmo!

        ragdoll\AddToObserveTargets!

        return ragdoll

do

    :Shuffle = table

    PLAYER.LootRagdoll = ( ragdoll ) =>
        velocity = vector_origin

        direction = @EyePos! - ragdoll\WorldSpaceCenter!
        direction\Normalize!

        if ragdoll.HasFlashlight and not @HasFlashlight!
            ragdoll.HasFlashlight = nil
            velocity += direction * 150
            @GiveFlashlight!

        if ragdoll.HasSecurityKeys and not @HasSecurityKeys!
            ragdoll.HasSecurityKeys = nil
            velocity += direction * 50
            @GiveSecurityKeys!

        if ragdoll.HasSecurityRadio and not @HasSecurityRadio!
            ragdoll.HasSecurityRadio = nil
            velocity += direction * 50
            @GiveSecurityRadio!

        :Weapons = ragdoll
        if Weapons ~= nil
            count, weapon = 0, NULL
            for index = 1, #Weapons
                weapon = Weapons[ index ]
                unless weapon\IsValid!
                    continue

                if weapon\GetOwner!\IsValid! or weapon\GetParent! ~= ragdoll
                    Weapons[ index ] = NULL
                    continue

                if Run( "PlayerCanPickupWeapon", @, weapon ) == false
                    count += 1
                    continue

                weapon\SetParent!
                weapon\SetNoDraw( false )
                weapon\SetNotSolid( false )
                weapon.PickupForbidden = nil

                @PickupWeapon( weapon )
                Weapons[ index ] = NULL

                velocity += direction * 200

            if count == 0
                ragdoll.Weapons = nil

        :Ammo = ragdoll
        if Ammo ~= nil
            count, amount = 0, 0
            for ammoType, ammoCount in pairs( Ammo )
                amount = min( ammoCount, @GetPickupAmmoCount( ammoType ) )
                if amount < 1
                    continue

                @GiveAmmo( amount, ammoType )
                velocity += direction * 100
                ammoCount -= amount

                if ammoCount > 0
                    Ammo[ ammoType ] = ammoCount
                    count += 1
                else
                    Ammo[ ammoType ] = nil

            if count == 0
                ragdoll.Ammo = nil

        if velocity\Length! < 100
            return

        if ragdoll\IsRagdoll!
            physParts, length = {}, 0
            for physNum = 1, ragdoll\GetPhysicsObjectCount! - 1
                phys = ragdoll\GetPhysicsObjectNum( physNum )
                if phys and phys\IsValid!
                    length += 1
                    physParts[ length ] = phys

            Shuffle( physParts )

            for index = 1, min( length, 6 )
                physParts[ index ]\ApplyForceCenter( velocity )

        else

            phys = ragdoll\GetPhysicsObject!
            if phys and phys\IsValid!
                phys\ApplyForceCenter( velocity )

        Run( "PlayerLootedRagdoll", @, ragdoll )

do

    angle_zero = angle_zero

    PLAYER.SpawnFromRagdoll = ( ragdoll, ignoreHealth ) =>
        @SetTeam( ragdoll\Team! )

        if ragdoll\Alive!
            if ply\Alive!
                @KillSilent!

            Simple 0, ->
                if not @IsValid! or @Alive!
                    return

                if ragdoll\IsValid!
                    @Spectate( OBS_MODE_CHASE )
                    @SpectateEntity( ragdoll )
                    return

                @Spectate( OBS_MODE_ROAMING )

            return false

        @SetModel( ragdoll\GetModel! )
        @SetPos( ragdoll\WorldSpaceCenter! )
        @SetEyeAngles( ragdoll.PlayerAngles or angle_zero )

        if ignoreHealth ~= false
            @SetHealth( @GetMaxHealth! * ( ragdoll\Health! / ragdoll\GetMaxHealth! ) )
            @SetArmor( @GetMaxArmor! * ( ragdoll.Armor / ragdoll.MaxArmor ) )

        @SetPlayerColor( ragdoll\GetPlayerColor! )
        @SetMaterial( ragdoll\GetMaterial! )
        @SetColor( ragdoll\GetColor! )
        @SetSkin( ragdoll\GetSkin! )

        for bodygroup in *@GetBodyGroups!
            @SetBodygroup( bodygroup.id, ragdoll\GetBodygroup( bodygroup.id ) )

        for index = 1, #@GetMaterials!
            materialPath = ragdoll\GetSubMaterial( index )
            if materialPath ~= ""
                @SetSubMaterial( index, materialPath )

        if ragdoll\IsOnFire!
            ragdoll\Extinguish!
            @Ignite( 5, 16 )

        for bone = 0, @GetBoneCount! - 1
            @ManipulateBonePosition( bone, ragdoll\GetManipulateBonePosition( bone ) )
            @ManipulateBoneAngles( bone, ragdoll\GetManipulateBoneAngles( bone ) )
            @ManipulateBoneJiggle( bone, ragdoll\GetManipulateBoneJiggle( bone ) )
            @ManipulateBoneScale( bone, ragdoll\GetManipulateBoneScale( bone ) )

        if ragdoll\IsRagdoll!
            velocity = vector_origin

            count = ragdoll\GetPhysicsObjectCount!
            for physNum = 0, count - 1
                phys = ragdoll\GetPhysicsObjectNum( physNum )
                if phys and phys\IsValid!
                    velocity += phys\GetVelocity!

            velocity /= count
            @SetVelocity( velocity )

        else

            phys = ragdoll\GetPhysicsObject!
            if phys and phys\IsValid!
                @SetVelocity( phys\GetVelocity! )

        if ragdoll.HasShockCollar
            ragdoll.HasShockCollar = nil
            @GiveShockCollar!

        @Give( "jb_hands", false, true )
        @LootRagdoll( ragdoll )
        return true

do

    trace = {}

    fixupProp = ( entity, origin, mins, maxs ) =>
        downEndPos, upEndPos = entity\LocalToWorld( mins ), entity\LocalToWorld( maxs )
        trace.filter = { entity, @ }

        trace.start = origin
        trace.endpos = downEndPos
        traceResultDown = TraceLine( trace )

        trace.start = origin
        trace.endpos = upEndPos
        traceResultUp = TraceLine( trace )

        -- Both traces hit meaning we are probably inside a wall on both sides, do nothing
        if traceResultUp.Hit and traceResultDown.Hit
            return

        if traceResultDown.Hit
            entity\SetPos( origin + ( traceResultDown.HitPos - downEndPos ) )

        if traceResultUp.Hit
            entity\SetPos( origin + ( traceResultUp.HitPos - upEndPos ) )

    tryFixPosition = ( entity, origin ) =>
        mins, maxs = entity\GetCollisionBounds!
        mins[ 2 ], mins[ 3 ] = 0, 0
        maxs[ 2 ], maxs[ 3 ] = 0, 0

        fixupProp( @, entity, origin, mins, maxs )

        mins, maxs = entity\GetCollisionBounds!
        mins[ 1 ], mins[ 3 ] = 0, 0
        maxs[ 1 ], maxs[ 3 ] = 0, 0

        fixupProp( @, entity, origin, mins, maxs )

        mins, maxs = entity\GetCollisionBounds!
        mins[ 1 ], mins[ 2 ] = 0, 0
        maxs[ 1 ], maxs[ 2 ] = 0, 0

        fixupProp( @, entity, origin, mins, maxs )

    PLAYER.SpawnEntity = ( className, preSpawn ) =>
        trace.start = @GetShootPos!
        unless IsInWorld( trace.start )
            return NULL

        trace.endpos = trace.start + ( @GetAimVector! * 128 )
        trace.filter = @

        entity = Create( className )
        unless entity and entity\IsValid!
            return NULL

        traceResult = TraceLine( trace )

        origin = traceResult.HitPos
        entity\SetPos( origin )

        angles = @EyeAngles!
        angles[ 1 ] = 0
        angles[ 2 ] += 180
        angles[ 3 ] = 0

        entity\SetAngles( angles )

        if preSpawn ~= nil
            preSpawn( entity, @ )

        entity\Spawn!
        entity\Activate!

        origin = entity\NearestPoint( origin - ( traceResult.HitNormal * entity\OBBMins! ) )
        entity\SetPos( origin )

        tryFixPosition( @, entity, origin )
        entity\PhysWake!
        return entity

ENTITY = FindMetaTable( "Entity" )

do

    :PrecacheModel, :IsValidModel = util
    :SetupHands = PLAYER
    :SetModel = ENTITY

    PLAYER.SetModel = ( modelPath ) =>
        modelPath = FixModelPath( modelPath )
        if IsValidModel( modelPath )
            PrecacheModel( modelPath )
            SetModel( @, modelPath )
            Run( "PlayerModelChanged", @, modelPath )
            SetupHands( @ )
            return true

        return false

do

    :GetNW2Int = ENTITY

    PLAYER.GetSpawnTime = =>
        return GetNW2Int( @, "spawn-time" )
