:min, :floor, :random = math
EffectData = EffectData
Jailbreak = Jailbreak
hook_Run = hook.Run
IsValid = IsValid
util = util
:Effect = util

-- Networking
util.AddNetworkString( "Jailbreak::Networking" )

-- Workshop content
resource.AddWorkshop( "3093227948" )
resource.AddWorkshop( "2950445307" )
resource.AddWorkshop( "2661291057" )
resource.AddWorkshop( "643148462" )

-- https://wiki.facepunch.com/gmod/Enums/NOTIFY
global NOTIFY_GENERIC = 0
global NOTIFY_ERROR = 1
global NOTIFY_UNDO = 2
global NOTIFY_HINT = 3
global NOTIFY_CLEANUP = 4

-- TF2 teams to jailbreak teams
Jailbreak.TF2Team = ( teamID ) ->
    return teamID % 2 + 1

do

    :Start, :WriteUInt, :WriteString, :Broadcast = net

    Jailbreak.PlaySound = ( soundPath ) ->
        Start( "Jailbreak::Networking" )
        WriteUInt( 3, 4 )
        WriteString( soundPath )
        Broadcast!

do

    :DelayedRemove = Jailbreak
    :BlastDamage = util
    :ceil = math

    Jailbreak.Explosion = ( inflictor, attacker, origin, radius, damage ) ->
        fx = EffectData!
        fx\SetOrigin( origin )

        scale = ceil( radius / 125 )
        fx\SetRadius( scale )
        fx\SetScale( scale )

        fx\SetMagnitude( ceil( damage / 18.75 ) )

        Effect( "Sparks", fx )
        Effect( "Explosion", fx )

        BlastDamage( inflictor, attacker, origin, radius, damage )

-- Change player team
do

    :Teams, :TeamIsJoinable = Jailbreak
    NOTIFY_ERROR = NOTIFY_ERROR
    :Joinable = team

    Jailbreak.ChangeTeam = ( teamID ) =>
        unless Joinable( teamID )
            return

        oldTeamID = @Team!
        if oldTeamID == teamID
            @SendNotify( "#jb.error.already-on-team", NOTIFY_ERROR, 3 )
            return

        unless TeamIsJoinable( teamID )
            @SendNotify( "#jb.error.cant-do-that", NOTIFY_ERROR, 10 )
            return

        if @Alive!
            if Teams[ oldTeamID ]
                @Kill!
            else
                @KillSilent!

        @SetTeam( teamID )

-- Shock collar effect
do

    CHAN_STATIC = CHAN_STATIC

    Jailbreak.ShockCollarEffect = ( origin, pitch ) =>
        unless origin
            boneID = @LookupBone( "ValveBiped.Bip01_Head1" )
            if boneID and boneID >= 0
                matrix = @GetBoneMatrix( boneID )
                if matrix
                    origin = matrix\GetTranslation!

        fx = EffectData!
        fx\SetScale( 0.5 )
        fx\SetOrigin( origin or @EyePos! )
        fx\SetMagnitude( random( 3, 5 ) )
        fx\SetRadius( random( 1, 5 ) )
        Effect( "ElectricSpark", fx )

        @EmitSound( "Jailbreak.Shock", 75, pitch or random( 80, 120 ), 1, CHAN_STATIC, 0, 1 )

do

    SetGlobal2Bool = SetGlobal2Bool

    -- Female prison
    do

        :IsFemalePrison = Jailbreak

        Jailbreak.SetFemalePrison = ( bool ) ->
            if bool == IsFemalePrison!
                return

            SetGlobal2Bool( "female-prison", bool )

    -- Shock collars
    do

        :IsShockCollarsActive = Jailbreak

        Jailbreak.SetShockCollars = ( bool, silent ) ->
            if bool == IsShockCollarsActive!
                return

            SetGlobal2Bool( "shock-collars", bool )

            unless silent
                hook_Run( "ShockCollars", bool )

-- Warden coins
do

    SetGlobal2Int = SetGlobal2Int
    :GetWardenCoins = Jailbreak

    Jailbreak.SetWardenCoins = ( value, silent ) ->
        oldValue = GetWardenCoins!
        if value == oldValue
            return

        SetGlobal2Int( "warden-coins", value )

        unless silent
            hook_Run( "WardenCoins", oldValue, value )

-- Entity metatable
do

    ENTITY = FindMetaTable( "Entity" )
    :GetClass = ENTITY

    -- Returns entity mass in kilograms
    do

        :GetPhysicsObjectCount, :GetPhysicsObjectNum = ENTITY

        ENTITY.GetPhysicsMass = =>
            objectMass = 0

            for physNum = 0, GetPhysicsObjectCount( @ ) - 1
                phys = GetPhysicsObjectNum( @, physNum )
                if IsValid( phys )
                    objectMass += phys\GetMass!

            return objectMass

    -- Entity dissolve method
    do

        :Simple = timer

        ENTITY.Dissolve = =>
            dissolver = ENTITY.Dissolver
            unless IsValid( dissolver )
                dissolver = ents.Create( "env_entity_dissolver" )
                ENTITY.Dissolver = dissolver

                dissolver\SetKeyValue( "dissolvetype", 0 )
                dissolver\SetKeyValue( "magnitude", 0 )
                dissolver\Spawn!

            unless IsValid( dissolver )
                return false

            dissolver\SetPos( @WorldSpaceCenter! )

            temporaryName = "dissolver" .. dissolver\EntIndex! .. "_request" .. @EntIndex!
            @SetName( temporaryName )

            dissolver\Fire( "dissolve", temporaryName, 0 )

            Simple 0, ->
                if @IsValid!
                    @SetName( "" )

            return true

    -- Returns true if the entity is valid observe target
    do

        :AllowRagdollSpectate = Jailbreak

        ENTITY.IsValidObserveTarget = =>
            if @IsPlayer! and @Alive!
                return true

            if @IsPlayerRagdoll!
                return AllowRagdollSpectate\GetBool!

            return GetClass( @ ) == "info_observer_point"

    do

        :ObserveTargets = Jailbreak
        :remove = table

        -- Remove the entity from the list of observe targets
        removeAsObserveTarget = =>
            for index = 1, #ObserveTargets
                if ObserveTargets[ index ] == @
                    remove( ObserveTargets, index )
                    break

        ENTITY.RemoveFromObserveTargets = removeAsObserveTarget

        -- Add the entity to the list of observe targets
        ENTITY.AddToObserveTargets = =>
            removeAsObserveTarget( @ )
            ObserveTargets[] = @

    -- Returns true if door entity is locked
    ENTITY.IsDoorLocked = =>
        return @GetInternalVariable( "m_bLocked" )

    -- Returns door entity state
    ENTITY.GetDoorState = =>
        return @GetInternalVariable( "m_eDoorState" )

do

    CTakeDamageInfo = FindMetaTable( "CTakeDamageInfo" )
    :GetDamageType = CTakeDamageInfo
    :band, :bor = bit

    -- Returns true if the damage type is close range
    do

        DMG_CLOSE_RANGE = bor( DMG_SLASH, DMG_FALL, DMG_CLUB, DMG_CRUSH )

        CTakeDamageInfo.IsCloseRangeDamage = =>
            return band( GetDamageType( @ ), DMG_CLOSE_RANGE ) ~= 0

    -- Returns true if the damage type is dissolve
    do

        DMG_DISSOLVE = DMG_DISSOLVE

        CTakeDamageInfo.IsDissolveDamage = =>
            return band( GetDamageType( @ ), DMG_DISSOLVE ) == DMG_DISSOLVE


    -- Returns true if the damage type is non physical
    do

        DMG_NON_PHYSICAL = bor( DMG_DROWN, DMG_POISON, DMG_RADIATION, DMG_NERVEGAS, DMG_PARALYZE, DMG_SHOCK, DMG_SONIC, DMG_BURN )

        CTakeDamageInfo.IsNonPhysicalDamage = =>
            return band( GetDamageType( @ ), DMG_NON_PHYSICAL ) ~= 0

    -- Returns true if the damage type is crush damage
    do

        DMG_CRUSH = DMG_CRUSH

        CTakeDamageInfo.IsCrushDamage = =>
            return band( GetDamageType( @ ), DMG_CRUSH ) == DMG_CRUSH

    -- Returns true if the damage type is shock damage
    do

        DMG_SHOCK = DMG_SHOCK

        CTakeDamageInfo.IsShockDamage = =>
            return band( GetDamageType( @ ), DMG_SHOCK ) == DMG_SHOCK

do

    :GetAmmoMax = game
    istable = istable
    :Shuffle = table
    Vector = Vector
    pairs = pairs

    Jailbreak.LootRagdoll = ( ragdoll ) =>
        velocity = Vector!

        direction = @EyePos! - ragdoll\WorldSpaceCenter!
        direction\Normalize!

        if ragdoll.HasFlashlight and not @CanUseFlashlight!
            velocity += direction * 150
            @AllowFlashlight( true )
            @SendPickupNotify( "jb.flashlight" )
            ragdoll.HasFlashlight = nil

        if ragdoll.HasSecurityAccess and not @HasSecurityAccess!
            velocity += direction * 50
            @AllowSecurityAccess( true )
            @SendPickupNotify( "jb.security.keys" )
            ragdoll.HasSecurityAccess = nil

        if ragdoll.HasSecurityRadio and not @HasSecurityRadio!
            velocity += direction * 50
            @AllowSecurityRadio( true )
            @SendPickupNotify( "jb.walkie-talkie" )
            ragdoll.HasSecurityRadio = nil

        weapons = ragdoll.Weapons
        if istable( weapons )
            if next( weapons ) == nil
                ragdoll.Weapons = nil
            else
                for key, weapon in pairs( weapons )
                    unless weapon\IsValid!
                        weapons[ key ] = nil
                        continue

                    if IsValid( weapon\GetOwner! )
                        weapons[ key ] = nil
                        continue

                    if hook_Run( "PlayerCanPickupWeapon", @, weapon ) == false
                        continue

                    weapon\SetNotSolid( false )
                    weapon\SetNoDraw( false )
                    weapon\SetParent!

                    weapon.PickupForbidden = nil
                    @PickupWeapon( weapon )
                    weapons[ key ] = nil

                    velocity += direction * 200

        ammo = ragdoll.Ammo
        if istable( ammo )
            if next( ammo ) == nil
                ragdoll.Ammo = nil
            else
                for ammoType, ammoCount in pairs( ammo )
                    pickupAmount = min( ammoCount, floor( GetAmmoMax( ammoType ) - @GetAmmoCount( ammoType ) ) )
                    if pickupAmount < 1
                        continue

                    @GiveAmmo( pickupAmount, ammoType )
                    velocity += direction * 100

                    ammoCount -= pickupAmount
                    if ammoCount > 0
                        ammo[ ammoType ] = ammoCount
                    else
                        ammo[ ammoType ] = nil

        if velocity\Length! < 100
            return

        if ragdoll\IsRagdoll!
            physParts = {}
            for physNum = 1, ragdoll\GetPhysicsObjectCount! - 1 do
                phys = ragdoll\GetPhysicsObjectNum( physNum )
                if IsValid( phys )
                    physParts[] = phys

            Shuffle( physParts )

            for index = 1, min( #physParts, 4 )
                physParts[ index ]\ApplyForceCenter( velocity )

        else
            phys = ragdoll\GetPhysicsObject!
            if IsValid( phys )
                phys\ApplyForceCenter( velocity )

do

    tobool = tobool
    :lower = string

    GM.AcceptInput = ( entity, key ) =>
        if entity\GetClass! == "prop_door_rotating"
            switch lower( key )
                when "lock"
                    entity\SetNW2Bool( "m_bLocked", true )
                when "unlock"
                    entity\SetNW2Bool( "m_bLocked", false )

    GM.EntityKeyValue = ( entity, key, value ) =>
        if entity\GetClass! == "prop_door_rotating" and lower( key ) == "m_bLocked"
            entity\SetNW2Bool( key, tobool( value ) )

do

    :TraceLine, :Decal = util
    trace = {}

    Jailbreak.BloodSplashes = ( damageInfo, death, velocity ) =>
        unless velocity
            velocity = @GetVelocity! + damageInfo\GetDamageForce!

        damagePosition = damageInfo\GetDamagePosition!
        speed = velocity\Length!

        fx = EffectData!
        fx\SetNormal( velocity\GetNormalized! )
        fx\SetMagnitude( speed / 100 )
        fx\SetScale( 10 )
        fx\SetFlags( 3 )
        fx\SetColor( 0 )
        fx\SetOrigin( damagePosition )
        Effect( "BloodImpact", fx, true, true )

        trace.start = damagePosition
        trace.filter = @

        unless death
            trace.endpos = damagePosition + velocity
            traceResult = TraceLine( trace )
            unless traceResult.Hit
                return

            Decal( "Blood", traceResult.HitPos + traceResult.HitNormal, traceResult.HitPos - traceResult.HitNormal )
            return

        decal = damageInfo\IsShockDamage! and "FadingScorch" or "Blood"

        for bone = 0, @GetBoneCount! - 1
            origin = @GetBonePosition( bone )

            trace.endpos = origin + ( origin - damagePosition ) * speed
            traceResult = TraceLine( trace )

            if traceResult.Hit
                Decal( decal, traceResult.HitPos + traceResult.HitNormal, traceResult.HitPos - traceResult.HitNormal )
