Jailbreak = Jailbreak

:ceil, :random, :max, :floor, :Rand = math
CHAN_STATIC = CHAN_STATIC
DMG_SHOCK = DMG_SHOCK
IsValid = IsValid
Vector = Vector
Angle = Angle
pairs = pairs
GM = GM

do

    :ShockCollarVictimDamage, :ShockCollarAttackerDamage = Jailbreak
    NOTIFY_ERROR = NOTIFY_ERROR
    DMG_SONIC = DMG_SONIC

    GM.PlayerTakeDamage = ( ply, damageInfo, teamID ) =>
        if ply\HasShockCollar! and damageInfo\IsShockDamage!
            ply\DoElectricSparks!
            ply\TakeShockCollar( true )
            ply\SendNotify( "#jb.notify.shock-collar.broken", NOTIFY_ERROR, 10 )

        attacker = damageInfo\GetAttacker!
        attackerIsPlayer = attacker\IsValid! and attacker\IsPlayer!
        isCloseRangeDamage = damageInfo\IsCloseRangeDamage!

        if attackerIsPlayer and isCloseRangeDamage and attacker\ShockCollarIsEnabled! and attacker ~= ply
            damage, damageType = damageInfo\GetDamage!, damageInfo\GetDamageType!
            newDamage = damage * ShockCollarAttackerDamage\GetFloat!
            if newDamage >= 1
                attacker\DoElectricSparks!
                damageInfo\SetDamage( newDamage )
                damageInfo\SetDamageType( DMG_SONIC )
                attacker\TakeDamageInfo( damageInfo )

            damageInfo\SetDamageType( damageType )
            damageInfo\SetDamage( damage * ShockCollarVictimDamage\GetFloat! )

        inflictor = damageInfo\GetInflictor!
        if inflictor\IsValid! and inflictor\IsWeapon!
            unless inflictor\IsScripted!
                return

            if isCloseRangeDamage and inflictor\GetClass! ~= "jb_hands"
                force = damageInfo\GetDamageForce!
                if force\Length! > 1000
                    force[ 1 ], force[ 2 ], force[ 3 ] = 0, 0, 0
                    damageInfo\SetDamageForce( force )

                return

        velocity = damageInfo\GetDamageForce!
        if velocity\Length! < 1
            return

        if Jailbreak.PowerfulPlayers and attackerIsPlayer and isCloseRangeDamage
            velocity *= 3

        velocity[ 1 ] /= 10
        velocity[ 2 ] /= 10
        velocity[ 3 ] /= 8
        ply\SetVelocity( velocity )

do

    unflamableMaterials = {
        [ MAT_METAL ]: true
        [ MAT_GRATE ]: true
        [ MAT_TILE ]: true
        [ MAT_SAND ]: true
        [ MAT_VENT ]: true
        [ MAT_CONCRETE ]: true
        [ MAT_SNOW ]: true
        [ MAT_GLASS ]: true
        [ MAT_DEFAULT ]: true
    }

    Jailbreak.UnflamableMaterials = unflamableMaterials

    GM.EntityTakeFireDamage = ( entity, damageInfo ) =>
        unless entity\IsOnFire!
            return

        if entity\WaterLevel! >= 2
            entity\Extinguish!
            return

        if entity\IsPlayer!
            unless entity\Alive!
                entity\Extinguish!
                return true

            if entity\GetVelocity!\Length! > 800
                entity\Extinguish!
                return true

        elseif unflamableMaterials[ entity\GetMaterialType! ]
            entity\Extinguish!
            return true

do

    :Teams, :IsRoundPreparing, :IsProp = Jailbreak
    :IsValidModel, :IsInWorld, :Effect = util
    MOVETYPE_VPHYSICS = MOVETYPE_VPHYSICS
    SOLID_VPHYSICS = SOLID_VPHYSICS
    DMG_NEVERGIB = DMG_NEVERGIB
    EffectData = EffectData
    DMG_BLAST = DMG_BLAST
    DMG_BURN = DMG_BURN
    isnumber = isnumber
    istable = istable
    :find = string
    :Create = ents
    :band = bit
    :Run = hook

    sk_npc_dmg_fraggrenade = GetConVar( "sk_npc_dmg_fraggrenade" )
    sk_fraggrenade_radius = GetConVar( "sk_fraggrenade_radius" )

    materials = {
        [ MAT_GLASS ]: 0.5
        [ MAT_CONCRETE ]: 5
        [ MAT_SLOSH ]: 0.25
        [ MAT_GRATE ]: 8
        [ MAT_DIRT ]: 3
        [ MAT_TILE ]: 2
        [ MAT_FOLIAGE ]: 1.5
        [ MAT_VENT ]: 0.25
        [ MAT_WOOD ]: 3
        [ MAT_COMPUTER ]: 0.25
        [ MAT_METAL ]: 8
        [ MAT_PLASTIC ]: 1.25
        [ MAT_GRASS ]: 0.25
        [ MAT_DEFAULT ]: 16
        [ MAT_FLESH ]: 0.5
        [ MAT_BLOODYFLESH ]: 0.25
    }

    Jailbreak.DamageMaterials = materials

    dropList = {
        ["models/props/de_inferno/crate_fruit_break.mdl"]: {
            ["Models"]: "models/props/cs_italy/orange.mdl"
            ["Count"]: { 16, 32 }
        }
    }

    Jailbreak.BreakDropList = dropList

    cache = {}

    GM.EntityTakeDamage = ( entity, damageInfo ) =>
        if entity\IsWeapon!
            className = entity\GetClass!
            if className == "weapon_frag" and not entity.Exploded
                entity.Exploded = true

                radius = sk_fraggrenade_radius\GetInt!
                if damageInfo\IsExplosionDamage!
                    radius *= random( 1, 4 )

                Jailbreak.Explosion( entity, damageInfo\GetAttacker!, entity\WorldSpaceCenter!, radius, sk_npc_dmg_fraggrenade\GetInt! )
                entity\Remove!

            return true

        if damageInfo\IsExplosionDamage!
            damageInfo\SetDamage( damageInfo\GetDamage! + damageInfo\GetDamageForce!\Length! / 256 )

        if entity\IsPlayerRagdoll!
            inflictor = damageInfo\GetInflictor!
            if inflictor\IsValid! and inflictor\GetClass! == "prop_combine_ball"
                entity\Dissolve!
            else
                Run( "RagdollTakeDamage", entity, damageInfo, true )

            return true

        damageType = damageInfo\GetDamageType!
        if band( damageType, DMG_BURN ) == DMG_BURN and Run( "EntityTakeFireDamage", entity, damageInfo ) == true
            return true

        if Jailbreak.PowerfulPlayers
            attacker = damageInfo\GetAttacker!
            if attacker\IsValid! or attacker\IsPlayer!
                damageInfo\ScaleDamage( 2 )

        if entity\IsRagdoll!
            return Run( "RagdollTakeDamage", entity, damageInfo, false )

        elseif entity\IsPlayer!
            if entity\Alive! and not entity\HasGodMode!
                teamID = entity\Team!
                if Teams[ teamID ] and Run( "CanPlayerTakeDamage", entity, damageInfo, teamID ) ~= false
                    return Run( "PlayerTakeDamage", entity, damageInfo, teamID )

            return true

        className = entity\GetClass!
        if IsRoundPreparing!
            if className == "func_button"
                return

            return true

        if band( damageType, DMG_NEVERGIB ) == DMG_NEVERGIB
            return

        if IsProp( className )
            maxHealth = entity\GetMaxHealth!
            if maxHealth <= 1 and entity\Health! < 1
                health = cache[ entity\GetModel! ]
                unless health
                    mins, maxs = entity\GetCollisionBounds!
                    health = ceil( mins\Distance( maxs ) * ( materials[ entity\GetMaterialType! or 0 ] or 1 ) )
                    cache[ entity\GetModel! ] = health

                entity\SetHealth( health )
                entity\SetMaxHealth( health )
                return

            health = max( 0, entity\Health! - damageInfo\GetDamage! )
            if health > 1
                entity\SetHealth( health )

                if ( health / maxHealth ) > 0.5
                    return true

                changed = false
                if entity\GetMoveType! ~= MOVETYPE_VPHYSICS
                    entity\SetMoveType( MOVETYPE_VPHYSICS )
                    changed = true

                phys = entity\GetPhysicsObject!
                if IsValid( phys )
                    if phys\IsMoveable!
                        unless phys\IsMotionEnabled!
                            phys\EnableMotion( true )
                            changed = true

                        if phys\IsAsleep!
                            phys\Wake!

                    else
                        entity\PhysicsInit( SOLID_VPHYSICS )
                        entity\PhysWake!
                        changed = true

                if changed
                    fx = EffectData!
                    fx\SetOrigin( entity\WorldSpaceCenter! )
                    fx\SetMagnitude( 5 )
                    fx\SetRadius( 5 )
                    fx\SetScale( 2 )
                    Effect( "Sparks", fx )

                    entity\EmitSound( "physics/metal/metal_box_break" .. random( 1, 2 ) .. ".wav", 70, random( 80, 120 ), 1, CHAN_STATIC, 0, 1 )

                return true

            velocity = entity\GetVelocity! + damageInfo\GetDamageForce!
            if entity\PrecacheGibs! > 0
                entity\GibBreakClient( velocity )

            dropModels = dropList[ entity\GetModel! ]
            if dropModels ~= nil
                count = dropModels.Count
                if istable( count )
                    count = random( count[ 1 ], count[ 2 ] )
                elseif not isnumber( count )
                    count = 1

                dropModels = dropModels.Models
                isTable = istable( dropModels )
                if isTable or isstring( dropModels )
                    mins, maxs = entity\GetCollisionBounds!
                    speed = velocity\Length!

                    mins *= 0.8
                    maxs *= 0.8

                    for i = 1, count
                        prop = Create( "prop_physics" )

                        if isTable
                            prop\SetModel( dropModels[ random( 1, #dropModels ) ] )
                        else
                            prop\SetModel( dropModels )

                        prop\SetPos( entity\LocalToWorld( Vector( random( mins[ 1 ], maxs[ 1 ] ), random( mins[ 2 ], maxs[ 2 ] ), random( mins[ 3 ], maxs[ 3 ] ) ) ) )
                        prop\SetAngles( Angle( random( -180, 180 ), random( -180, 180 ), random( -180, 180 ) ) )
                        prop\Spawn!

                        phys = prop\GetPhysicsObject!
                        if IsValid( phys )
                            phys\ApplyForceCenter( Vector( random( -1, 1 ), random( -1, 1 ), random( -1, 1 ) ) * speed )

            entity\Remove!

            return true

        switch className
            when "prop_door_rotating"
                model = entity\GetModel!
                unless model and #model ~= 0 and IsValidModel( model )
                    return true

                maxHealth = entity\GetMaxHealth!
                if maxHealth <= 1
                    maxHealth = Jailbreak.DoorsHealth\GetInt!
                    if maxHealth <= 0
                        return true

                    entity\SetHealth( maxHealth )
                    entity\SetMaxHealth( maxHealth )

                health = entity\Health!
                if health < 1
                    return true

                health = max( 0, health - damageInfo\GetDamage! )
                entity\SetHealth( health )

                if health > 1
                    return true

                center = entity\OBBCenter!
                center[ 1 ] = 0
                center[ 2 ] = 0

                origin = entity\LocalToWorld( center )
                unless IsInWorld( origin )
                    return true

                prop = Create( "prop_physics" )
                prop\SetCollisionGroup( COLLISION_GROUP_WEAPON )
                prop\SetAngles( entity\GetAngles! )
                prop\SetSkin( entity\GetSkin! )
                prop\SetModel( model )
                prop\SetPos( origin )
                prop\Spawn!

                prop\EmitSound( "physics/wood/wood_crate_break" .. random( 1, 5 ) .. ".wav", 70, random( 80, 120 ), 1, CHAN_STATIC, 0, 1 )
                entity\Remove!

                phys = prop\GetPhysicsObject!
                if IsValid( phys )
                    phys\ApplyForceOffset( damageInfo\GetDamageForce!, damageInfo\GetDamagePosition! )

                origin = damageInfo\GetDamagePosition!
                util.ScreenShake( origin, 5, 10, 0.5, 150 )

                fx = EffectData!
                fx\SetOrigin( origin )
                fx\SetMagnitude( 5 )
                fx\SetRadius( 5 )
                fx\SetScale( 2 )
                Effect( "Sparks", fx )

                return true

            when "func_button"
                if band( damageType, DMG_BLAST ) == DMG_BLAST
                    return true

                attacker = damageInfo\GetAttacker!
                if attacker\IsValid! and attacker\IsPlayer! and random( 0, 1 ) == 1
                    entity\Use( attacker, attacker )

                    damageOrigin = damageInfo\GetDamagePosition!
                    entity\DoElectricSparks( damageOrigin, 150 )

                    if damageInfo\IsCloseRangeDamage!
                        attacker\Ignite( 0.25, 16 )

                        dir = attacker\WorldSpaceCenter! - damageOrigin
                        dir[ 3 ] = 1

                        damageInfo\SetDamage( attacker\GetMaxHealth! / Rand( 2, 3 ) )
                        damageInfo\SetDamageForce( dir * 100 )
                        damageInfo\SetDamageType( DMG_SHOCK )
                        damageInfo\SetAttacker( entity )
                        attacker\TakeDamageInfo( damageInfo )

                return true

        inflictor = damageInfo\GetInflictor!
        if inflictor\IsValid! and inflictor\IsWeapon!
            unless inflictor\IsScripted!
                return

            if damageInfo\IsCloseRangeDamage! and inflictor\GetClass! ~= "jb_hands"
                return

        velocity = damageInfo\GetDamageForce!
        if velocity\Length! < 1
            return

        origin = damageInfo\GetDamagePosition!
        for physNum = 0, entity\GetPhysicsObjectCount! - 1
            phys = entity\GetPhysicsObjectNum( physNum )
            if IsValid( phys )
                phys\ApplyForceOffset( velocity, origin )

do

    player_old_armor = GetConVar( "player_old_armor" )

    GM.PerformArmorDamage = ( entity, armor, damageInfo ) =>
        if armor <= 0
            return 0

        if damageInfo\IsNonPhysicalDamage!
            return armor

        if damageInfo\IsCloseRangeDamage! and damageInfo\GetAttacker! == entity
            damageInfo\ScaleDamage( 0.25 )

        isEnabled = player_old_armor\GetBool!
        flBonus = isEnabled and 0.5 or 1 -- Each Point of Armor is worth 1/x points of health
        flRatio = 0.2 -- Armor Takes 80% of the damage

        damage = damageInfo\GetDamage!
        flNew = damage * flRatio
        flArmor = ( damage - flNew ) * flBonus

        if not isEnabled and flArmor < 1
            flArmor = 1

        if flArmor > armor
            flArmor = armor * ( 1 / flBonus )
            flNew = damage - flArmor
            armor = 0
        else
            armor -= flArmor

        damageInfo\SetDamage( flNew )
        return armor

do

    BLOOD_COLOR_MECH = BLOOD_COLOR_MECH
    BLOOD_COLOR_RED = BLOOD_COLOR_RED

    GM.HandlePlayerArmorReduction = ( ply, damageInfo ) =>
        ply\SetArmor( @PerformArmorDamage( ply, ply\Armor!, damageInfo ) )
        ply\SetBloodColor( ply\Armor! > 0 and BLOOD_COLOR_MECH or BLOOD_COLOR_RED )

GM.GetFallDamage = ( ply, speed ) =>
    return max( 0, ceil( 0.2418 * speed - 141.75 ) )

do

    LocalToWorld = LocalToWorld
    :BloodSplashes = Jailbreak

    GM.RagdollTakeDamage = ( ragdoll, damageInfo, isPlayerRagdoll ) =>
        unless isPlayerRagdoll
            return

        if damageInfo\IsCrushDamage!
            return true

        armor = ragdoll.Armor
        if armor ~= nil and armor > 0
            ragdoll.Armor = @PerformArmorDamage( ragdoll, armor, damageInfo )

        if damageInfo\IsExplosionDamage!
            damageInfo\ScaleDamage( 0.25 )
        else
            damageInfo\ScaleDamage( 0.025 )

        health = ragdoll\Health!
        nextHealth = floor( health - damageInfo\GetDamage! )
        ragdoll\SetHealth( nextHealth )

        if ragdoll.Alive
            startHealth = ragdoll.StartHealth
            unless startHealth
                startHealth = health
                ragdoll.StartHealth = startHealth

            if nextHealth / startHealth < 0.5
                ragdoll\EmitSound( "Player.Death", 75, random( 80, 120 ), 1, CHAN_STATIC, 0, 1 )
                ragdoll.Alive = false

        if nextHealth > 0
            BloodSplashes( ragdoll, damageInfo, false )
            return

        velocity = ragdoll\GetVelocity! + damageInfo\GetDamageForce!
        BloodSplashes( ragdoll, damageInfo, true, velocity )

        if ragdoll.Weapons ~= nil
            origin, angles = ragdoll\WorldSpaceCenter!, ragdoll\GetAngles!
            mins, maxs = ragdoll\GetCollisionBounds!
            mins, maxs = mins * 0.5, maxs * 0.5

            for weapon in *ragdoll.Weapons
                unless weapon\IsValid!
                    continue

                weapon\SetParent!
                weapon\SetNoDraw( false )
                weapon\SetNotSolid( false )

                origin, angles = LocalToWorld( Vector( random( mins[ 1 ], maxs[ 1 ], random( mins[ 2 ], maxs[ 2 ] ), random( mins[ 3 ], maxs[ 3 ] ) ) ), Angle( Rand( -90, 90 ), Rand( -180, 180 ), Rand( -180, 180 ) ), origin, angles )
                weapon\SetAngles( angles )
                weapon\SetPos( origin )

                phys = weapon\GetPhysicsObject!
                if IsValid( phys )
                    phys\SetVelocity( velocity )
                    phys\Wake!

                weapon.PickupForbidden = nil

            ragdoll.Weapons = nil

        if ragdoll\PrecacheGibs! > 0
            ragdoll\GibBreakClient( velocity )
        elseif random( 1, 2 ) == 1
            ragdoll\EmitSound( "physics/body/body_medium_break" .. random( 2, 4 ) .. ".wav", 70, random( 80, 120 ), 1, CHAN_STATIC, 0, 1 )
        else
            ragdoll\EmitSound( "physics/flesh/flesh_squishy_impact_hard" .. random( 1, 4 ) .. ".wav", 70, random( 80, 120 ), 1, CHAN_STATIC, 0, 1 )

        ragdoll\Remove!
