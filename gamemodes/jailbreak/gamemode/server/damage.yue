Jailbreak = Jailbreak

:ceil, :random, :max, :floor, :Rand = math
:ShockCollarEffect = Jailbreak
DMG_SHOCK = DMG_SHOCK
GM = GM

do

    :ShockCollarVictimDamage, :ShockCollarAttackerDamage, :IsShockCollarsActive = Jailbreak
    NOTIFY_ERROR = NOTIFY_ERROR
    DMG_SONIC = DMG_SONIC
    :band = bit

    GM.PlayerTakeDamage = ( ply, damageInfo, teamID ) =>
        damageType = damageInfo\GetDamageType!
        if ply\HasShockCollar! and band( damageType, DMG_SHOCK ) == DMG_SHOCK
            ply\SendNotify( "#jb.notify.shock-collar.broken", NOTIFY_ERROR, 10 )
            ply\SetShockCollar( false )
            ShockCollarEffect( ply )

        attacker = damageInfo\GetAttacker!
        attackerIsPlayer = attacker\IsValid! and attacker\IsPlayer!
        isCloseRangeDamage = damageInfo\IsCloseRangeDamage!

        if IsShockCollarsActive! and attackerIsPlayer and isCloseRangeDamage and attacker\HasShockCollar! and attacker ~= ply
            damage = damageInfo\GetDamage!

            newDamage = damage * ShockCollarAttackerDamage\GetFloat!
            if newDamage >= 1
                ShockCollarEffect( attacker )
                damageInfo\SetDamage( newDamage )
                damageInfo\SetDamageType( DMG_SONIC )
                attacker\TakeDamageInfo( damageInfo )

            damageInfo\SetDamageType( damageType )
            damageInfo\SetDamage( damage * ShockCollarVictimDamage\GetFloat! )

        inflictor = damageInfo\GetInflictor!
        if inflictor\IsValid! and inflictor\IsWeapon!
            unless inflictor\IsScripted!
                return

            if isCloseRangeDamage and inflictor\GetClass! ~= "jb_hands"
                force = damageInfo\GetDamageForce!
                if force\Length! > 1000
                    force[ 1 ], force[ 2 ], force[ 3 ] = 0, 0, 0
                    damageInfo\SetDamageForce( force )

                return

        velocity = damageInfo\GetDamageForce!
        if velocity\Length! < 1
            return

        if Jailbreak.PowerfulPlayers and attackerIsPlayer and isCloseRangeDamage
            velocity *= 3

        velocity[ 1 ] /= 10
        velocity[ 2 ] /= 10
        velocity[ 3 ] /= 8
        ply\SetVelocity( velocity )

GM.EntityTakeFireDamage = ( entity, damageInfo ) =>
    if entity\IsOnFire! and ( entity\WaterLevel! >= 2 or ( entity\IsPlayer! and ( not entity\Alive! or entity\GetVelocity!\Length! > 800 ) ) )
        entity\Extinguish!
        return true

do

    :IsValidModel, :IsInWorld, :Effect, :ScreenShake = util
    :Teams, :DoorsHealth, :GameInProgress = Jailbreak
    COLLISION_GROUP_WEAPON = COLLISION_GROUP_WEAPON
    DMG_NEVERGIB = DMG_NEVERGIB
    CHAN_STATIC = CHAN_STATIC
    EffectData = EffectData
    DMG_BLAST = DMG_BLAST
    hook_Run = hook.Run
    DMG_BURN = DMG_BURN
    IsValid = IsValid
    :Create = ents
    :band = bit

    GM.EntityTakeDamage = ( entity, damageInfo ) =>
        if entity\IsPlayerRagdoll!
            inflictor = damageInfo\GetInflictor!
            if inflictor\IsValid! and inflictor\GetClass! == "prop_combine_ball"
                entity\Dissolve!
            else
                hook_Run( "RagdollTakeDamage", entity, damageInfo, true )

            return true

        damageType = damageInfo\GetDamageType!
        if band( damageType, DMG_BURN ) == DMG_BURN and hook_Run( "EntityTakeFireDamage", entity, damageInfo ) == true
            return true

        if Jailbreak.PowerfulPlayers
            attacker = damageInfo\GetAttacker!
            if attacker\IsValid! or attacker\IsPlayer!
                damageInfo\ScaleDamage( 2 )

        if entity\IsRagdoll!
            return hook_Run( "RagdollTakeDamage", entity, damageInfo, false )

        elseif entity\IsPlayer!
            if entity\Alive! and not entity\HasGodMode!
                teamID = entity\Team!
                if Teams[ teamID ] and hook_Run( "CanPlayerTakeDamage", entity, damageInfo, teamID ) ~= false
                    return hook_Run( "PlayerTakeDamage", entity, damageInfo, teamID )

            return true

        className = entity\GetClass!
        unless GameInProgress!
            if className == "func_button"
                return

            return true

        if band( damageType, DMG_NEVERGIB ) == DMG_NEVERGIB
            return

        switch className
            when "prop_door_rotating"
                model = entity\GetModel!
                unless model and #model ~= 0 and IsValidModel( model )
                    return true

                maxHealth = entity\GetMaxHealth!
                if maxHealth <= 1
                    maxHealth = DoorsHealth\GetInt!
                    if maxHealth <= 0
                        return true

                    entity\SetHealth( maxHealth )
                    entity\SetMaxHealth( maxHealth )

                health = entity\Health!
                if health < 1
                    return true

                health = max( 0, health - damageInfo\GetDamage! )
                entity\SetHealth( health )

                if health > 1
                    return true

                center = entity\OBBCenter!
                center[ 1 ] = 0
                center[ 2 ] = 0

                origin = entity\LocalToWorld( center )
                unless IsInWorld( origin )
                    return true

                prop = Create( "prop_physics" )
                prop\SetCollisionGroup( COLLISION_GROUP_WEAPON )
                prop\SetAngles( entity\GetAngles! )
                prop\SetSkin( entity\GetSkin! )
                prop\SetModel( model )
                prop\SetPos( origin )
                prop\Spawn!

                prop\EmitSound( "physics/wood/wood_crate_break" .. random( 1, 5 ) .. ".wav", 70, random( 80, 120 ), 1, CHAN_STATIC, 0, 1 )
                entity\Remove!

                phys = prop\GetPhysicsObject!
                if IsValid( phys )
                    phys\ApplyForceOffset( damageInfo\GetDamageForce!, damageInfo\GetDamagePosition! )

                origin = damageInfo\GetDamagePosition!
                ScreenShake( origin, 5, 10, 0.5, 150 )

                fx = EffectData!
                fx\SetOrigin( origin )
                fx\SetMagnitude( 5 )
                fx\SetRadius( 5 )
                fx\SetScale( 2 )
                Effect( "Sparks", fx )

                return true
            when "func_button"
                if band( damageType, DMG_BLAST ) == DMG_BLAST
                    return true

                attacker = damageInfo\GetAttacker!
                if attacker\IsValid! and attacker\IsPlayer! and random( 0, 1 ) == 1
                    entity\Use( attacker, attacker )
                    ShockCollarEffect( entity, damageOrigin, 150 )

                    if damageInfo\IsCloseRangeDamage!
                        attacker\Ignite( 0.25, 16 )

                        damageOrigin = damageInfo\GetDamagePosition!
                        dir = attacker\WorldSpaceCenter! - damageOrigin
                        dir[ 3 ] = 1

                        damageInfo\SetDamage( attacker\GetMaxHealth! / Rand( 2, 3 ) )
                        damageInfo\SetDamageForce( dir * 100 )
                        damageInfo\SetDamageType( DMG_SHOCK )
                        damageInfo\SetAttacker( entity )
                        attacker\TakeDamageInfo( damageInfo )

                return true

        inflictor = damageInfo\GetInflictor!
        if inflictor\IsValid! and inflictor\IsWeapon!
            unless inflictor\IsScripted!
                return

            if damageInfo\IsCloseRangeDamage! and inflictor\GetClass! ~= "jb_hands"
                return

        velocity = damageInfo\GetDamageForce!
        if velocity\Length! < 1
            return

        origin = damageInfo\GetDamagePosition!
        for physNum = 0, entity\GetPhysicsObjectCount! - 1
            phys = entity\GetPhysicsObjectNum( physNum )
            if IsValid( phys )
                phys\ApplyForceOffset( velocity, origin )

do

    player_old_armor = GetConVar( "player_old_armor" )

    GM.PerformArmorDamage = ( entity, armor, damageInfo ) =>
        if armor <= 0
            return 0

        if damageInfo\IsNonPhysicalDamage!
            return armor

        if damageInfo\IsCloseRangeDamage! and damageInfo\GetAttacker! == entity
            damageInfo\ScaleDamage( 0.25 )

        isEnabled = player_old_armor\GetBool!
        flBonus = isEnabled and 0.5 or 1 -- Each Point of Armor is worth 1/x points of health
        flRatio = 0.2 -- Armor Takes 80% of the damage

        damage = damageInfo\GetDamage!
        flNew = damage * flRatio
        flArmor = ( damage - flNew ) * flBonus

        if not isEnabled and flArmor < 1
            flArmor = 1

        if flArmor > armor
            flArmor = armor * ( 1 / flBonus )
            flNew = damage - flArmor
            armor = 0
        else
            armor -= flArmor

        damageInfo\SetDamage( flNew )
        return armor

do

    BLOOD_COLOR_MECH = BLOOD_COLOR_MECH
    BLOOD_COLOR_RED = BLOOD_COLOR_RED

    GM.HandlePlayerArmorReduction = ( ply, damageInfo ) =>
        ply\SetArmor( @PerformArmorDamage( ply, ply\Armor!, damageInfo ) )
        ply\SetBloodColor( ply\Armor! > 0 and BLOOD_COLOR_MECH or BLOOD_COLOR_RED )

GM.GetFallDamage = ( ply, speed ) =>
    return max( 0, ceil( 0.2418 * speed - 141.75 ) )

do

    LocalToWorld = LocalToWorld
    CHAN_STATIC = CHAN_STATIC
    Vector = Vector
    Angle = Angle
    pairs = pairs

    GM.RagdollTakeDamage = ( ragdoll, damageInfo, isPlayerRagdoll ) =>
        unless isPlayerRagdoll
            return

        if damageInfo\IsCrushDamage!
            return true

        armor = ragdoll.Armor
        if armor ~= nil and armor > 0
            ragdoll.Armor = @PerformArmorDamage( ragdoll, armor, damageInfo )

        health = ragdoll\Health!
        nextHealth = floor( health - ( damageInfo\GetDamage! * 0.025 ) )

        if ragdoll.Alive
            startHealth = ragdoll.StartHealth
            unless startHealth
                startHealth = health
                ragdoll.StartHealth = startHealth

            if nextHealth / startHealth < 0.5
                ragdoll\EmitSound( "Player.Death", 75, random( 80, 120 ), 1, CHAN_STATIC, 0, 1 )
                ragdoll.Alive = false

        if nextHealth > 0
            ragdoll\SetHealth( nextHealth )
            return

        velocity = ragdoll\GetVelocity! + damageInfo\GetDamageForce!

        weapons = ragdoll.Weapons
        if weapons ~= nil
            origin, angles = ragdoll\WorldSpaceCenter!, ragdoll\GetAngles!
            mins, maxs = ragdoll\GetCollisionBounds!

            mins *= 0.5
            maxs *= 0.5

            for _, weapon in pairs( weapons )
                unless weapon\IsValid!
                    continue

                weapon\SetParent!
                weapon\SetNoDraw( false )
                weapon\SetNotSolid( false )

                pos, ang = LocalToWorld( Vector( random( mins[ 1 ], maxs[ 1 ], random( mins[ 2 ], maxs[ 2 ] ), random( mins[ 3 ], maxs[ 3 ] ) ) ), Angle( Rand( -90, 90 ), Rand( -180, 180 ), Rand( -180, 180 ) ), origin, angles )
                weapon\SetAngles( ang )
                weapon\SetPos( pos )

                phys = weapon\GetPhysicsObject!
                if IsValid( phys )
                    phys\SetVelocity( velocity )
                    phys\Wake!

                weapon.PickupForbidden = nil

            ragdoll.Weapons = nil

        if ragdoll\PrecacheGibs! > 0
            ragdoll\GibBreakClient( velocity )
        else
            ragdoll\Remove!
