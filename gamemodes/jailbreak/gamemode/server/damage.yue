Jailbreak = Jailbreak

:ceil, :random, :max, :floor, :Rand = math
CHAN_STATIC = CHAN_STATIC
IsValid = IsValid
Vector = Vector
:Create = ents
Angle = Angle
:Run = hook
GM = GM

do

    :ShockCollarVictimDamage, :ShockCollarAttackerDamage = Jailbreak
    NOTIFY_ERROR = NOTIFY_ERROR
    DMG_SONIC = DMG_SONIC

    GM.PlayerTakeDamage = ( ply, damageInfo, teamID ) =>
        if ply\HasShockCollar! and damageInfo\IsShockDamage!
            ply\DoElectricSparks!
            ply\TakeShockCollar( true )
            ply\SendNotify( "#jb.notify.shock-collar.broken", NOTIFY_ERROR, 10 )

        attacker = damageInfo\GetAttacker!
        attackerIsPlayer = attacker\IsValid! and attacker\IsPlayer!
        isCloseRangeDamage = damageInfo\IsCloseRangeDamage!

        if attackerIsPlayer and isCloseRangeDamage and attacker\ShockCollarIsEnabled! and attacker ~= ply
            damage, damageType = damageInfo\GetDamage!, damageInfo\GetDamageType!
            newDamage = damage * ShockCollarAttackerDamage\GetFloat!
            if newDamage >= 1
                attacker\DoElectricSparks!
                damageInfo\SetDamage( newDamage )
                damageInfo\SetDamageType( DMG_SONIC )
                attacker\TakeDamageInfo( damageInfo )

            damageInfo\SetDamageType( damageType )
            damageInfo\SetDamage( damage * ShockCollarVictimDamage\GetFloat! )

        inflictor = damageInfo\GetInflictor!
        if inflictor\IsValid! and inflictor\IsWeapon!
            unless inflictor\IsScripted!
                return

            if isCloseRangeDamage and inflictor\GetClass! ~= "jb_hands"
                force = damageInfo\GetDamageForce!
                if force\Length! > 1000
                    force[ 1 ], force[ 2 ], force[ 3 ] = 0, 0, 0
                    damageInfo\SetDamageForce( force )

                return

        velocity = damageInfo\GetDamageForce!
        if velocity\Length! < 1
            return

        if Jailbreak.PowerfulPlayers and attackerIsPlayer and isCloseRangeDamage
            velocity *= 3

        velocity[ 1 ] /= 10
        velocity[ 2 ] /= 10
        velocity[ 3 ] /= 8
        ply\SetVelocity( velocity )

do

    unflamableMaterials = Jailbreak.UnflamableMaterials

    unless unflamableMaterials
        unflamableMaterials = {
            [ MAT_METAL ]: true
            [ MAT_GRATE ]: true
            [ MAT_TILE ]: true
            [ MAT_SAND ]: true
            [ MAT_VENT ]: true
            [ MAT_CONCRETE ]: true
            [ MAT_SNOW ]: true
            [ MAT_GLASS ]: true
            [ MAT_DEFAULT ]: true
        }

        Jailbreak.UnflamableMaterials = unflamableMaterials

    GM.AllowEntityExtinguish = ( entity ) =>
        if unflamableMaterials[ entity\GetMaterialType! ]
            return true

GM.EntityTakeFireDamage = ( entity, damageInfo ) =>
    unless entity\IsOnFire!
        return

    unless entity\IsSolid!
        entity\Extinguish!
        return true

    if entity\WaterLevel! >= 2
        entity\Extinguish!
        return

    if entity\IsPlayer!
        unless entity\Alive!
            entity\Extinguish!
            return true

        if entity\GetVelocity!\Length! > 800
            entity\Extinguish!
            return true

    elseif Run( "AllowEntityExtinguish", entity ) ~= false
        entity\Extinguish!
        return true

do

    :IsRoundPreparing, :IsProp = Jailbreak
    DMG_NEVERGIB = DMG_NEVERGIB
    :band = bit

    GM.EntityTakeDamage = ( entity, damageInfo ) =>
        if damageInfo\IsBurnDamage! and Run( "EntityTakeFireDamage", entity, damageInfo ) == true
            return true

        className = entity\GetClass!
        if IsRoundPreparing!
            if className == "func_button"
                return

            return true

        if entity\IsPlayer!
            if Run( "CanPlayerTakeDamage", entity, damageInfo, entity\Team! ) ~= false
                return Run( "PlayerTakeDamage", entity, damageInfo, entity\Team! )

            return true

        if className == "func_button"
            return Run( "ButtonTakeDamage", entity, damageInfo )

        if band( damageInfo\GetDamageType!, DMG_NEVERGIB ) == DMG_NEVERGIB
            return

        if entity\IsWeapon!
            return Run( "WeaponTakeDamage", entity, damageInfo )

        if entity\IsRagdoll!
            inflictor = damageInfo\GetInflictor!
            if inflictor\IsValid! and inflictor\GetClass! == "prop_combine_ball"
                entity\Dissolve!
                return true

            return Run( "RagdollTakeDamage", entity, damageInfo )

        if IsProp( className )
            return Run( "PropTakeDamage", entity, damageInfo )

        if className == "prop_door_rotating"
            return Run( "DoorTakeDamage", entity, damageInfo )

GM.PostEntityTakeDamage = ( entity, damageInfo, isRealDamage ) =>
    unless isRealDamage
        return

    if damageInfo\IsExplosionDamage!
        damageInfo\SetDamage( damageInfo\GetDamage! + damageInfo\GetDamageForce!\Length! / 256 )

    inflictor = damageInfo\GetInflictor!
    if inflictor\IsValid! and inflictor\IsWeapon!
        if not inflictor\IsScripted! and entity\IsPlayer!
            return

        if damageInfo\IsCloseRangeDamage! and inflictor\GetClass! ~= "jb_hands"
            return

    velocity = damageInfo\GetDamageForce!
    if velocity\Length! < 1
        return

    origin = damageInfo\GetDamagePosition!
    for physNum = 0, entity\GetPhysicsObjectCount! - 1
        phys = entity\GetPhysicsObjectNum( physNum )
        if phys and phys\IsValid! and phys\IsMoveable! and phys\IsMotionEnabled!
            phys\ApplyForceOffset( velocity, origin )
            phys\Wake!

do

    sk_npc_dmg_fraggrenade = GetConVar( "sk_npc_dmg_fraggrenade" )
    sk_fraggrenade_radius = GetConVar( "sk_fraggrenade_radius" )
    :Explosion = Jailbreak

    GM.WeaponTakeDamage = ( weapon, damageInfo ) =>
        switch weapon\GetClass!
            when "weapon_frag"
                if weapon.Exploded
                    return true

                weapon.Exploded = true

                radius = sk_fraggrenade_radius\GetInt!
                if damageInfo\IsExplosionDamage!
                    radius *= random( 1, 4 )

                Explosion( weapon, damageInfo\GetAttacker!, weapon\WorldSpaceCenter!, radius, sk_npc_dmg_fraggrenade\GetInt! )
                weapon\Remove!

        return true

do

    :IsValidModel, :IsInWorld = util
    :DoorsHealth = Jailbreak

    GM.DoorTakeDamage = ( door, damageInfo ) =>
        model = door\GetModel!
        if #model == 0 or not IsValidModel( model )
            return true

        maxHealth = door\GetMaxHealth!
        if maxHealth == 1
            maxHealth = DoorsHealth\GetInt!
            if maxHealth <= 0
                return true

            door\SetMaxHealth( maxHealth )
            door\SetHealth( maxHealth )

        health = max( 0, door\Health! - damageInfo\GetDamage! )
        door\SetHealth( health )

        if health >= 1
            return true

        center = door\OBBCenter!
        center[ 1 ], center[ 2 ] = 0, 0

        origin = door\LocalToWorld( center )
        unless IsInWorld( origin )
            door\Remove!
            return true

        prop = Create( "prop_physics" )
        prop\SetCollisionGroup( COLLISION_GROUP_WEAPON )
        prop\SetAngles( door\GetAngles! )
        prop\SetSkin( door\GetSkin! )
        prop\SetModel( model )
        prop\SetPos( origin )
        prop\Spawn!

        prop\EmitSound( "physics/wood/wood_crate_break" .. random( 1, 5 ) .. ".wav", 70, random( 80, 120 ), 1, CHAN_STATIC, 0, 1 )
        door\Remove!

        phys = prop\GetPhysicsObject!
        if phys and phys\IsValid!
            phys\ApplyForceOffset( damageInfo\GetDamageForce!, damageInfo\GetDamagePosition! )
            phys\Wake!

        origin = damageInfo\GetDamagePosition!
        util.ScreenShake( origin, 5, 10, 0.5, 150 )
        prop\DoElectricSparks( origin, nil, true )
        return true

do

    DMG_SHOCK = DMG_SHOCK

    GM.ButtonTakeDamage = ( button, damageInfo ) =>
        if damageInfo\IsExplosionDamage!
            return true

        attacker = damageInfo\GetAttacker!
        unless attacker\IsValid! and attacker\IsPlayer! and random( 0, 1 ) == 1
            return true

        button\DoElectricSparks( damageInfo\GetDamagePosition!, 150 )
        button\Use( attacker, attacker )

        unless damageInfo\IsCloseRangeDamage!
            return true

        attacker\Ignite( 0.5, 16 )

        dir = attacker\WorldSpaceCenter! - damageInfo\GetDamagePosition!
        dir[ 3 ] = 1

        damageInfo\SetDamage( attacker\GetMaxHealth! / Rand( 2, 3 ) )
        damageInfo\SetDamageForce( dir * 100 )
        damageInfo\SetDamageType( DMG_SHOCK )
        damageInfo\SetAttacker( button )
        attacker\TakeDamageInfo( damageInfo )
        return true

do

    MOVETYPE_VPHYSICS = MOVETYPE_VPHYSICS
    SOLID_VPHYSICS = SOLID_VPHYSICS
    isnumber = isnumber
    istable = istable

    dropList = Jailbreak.PropsDropList
    unless dropList
        dropList = {
            ["models/props/de_inferno/crate_fruit_break.mdl"]: {
                ["Models"]: "models/props/cs_italy/orange.mdl"
                ["Count"]: { 16, 32 }
            }
        }

        Jailbreak.PropsDropList = dropList

    materials = Jailbreak.PropDamageMaterials
    unless materials
        materials = {
            [ MAT_GLASS ]: 0.5
            [ MAT_CONCRETE ]: 5
            [ MAT_SLOSH ]: 0.25
            [ MAT_GRATE ]: 8
            [ MAT_DIRT ]: 3
            [ MAT_TILE ]: 2
            [ MAT_FOLIAGE ]: 1.5
            [ MAT_VENT ]: 0.25
            [ MAT_WOOD ]: 3
            [ MAT_COMPUTER ]: 0.25
            [ MAT_METAL ]: 8
            [ MAT_PLASTIC ]: 1.25
            [ MAT_GRASS ]: 0.25
            [ MAT_DEFAULT ]: 16
            [ MAT_FLESH ]: 0.5
            [ MAT_BLOODYFLESH ]: 0.25
        }

        Jailbreak.PropDamageMaterials = materials

    cache = {}

    GM.PropTakeDamage = ( entity, damageInfo ) =>
        if entity.CustomHealth == nil
            if entity\GetMaxHealth! == 1 and entity\Health! == 0
                health = cache[ entity\GetModel! ]
                unless health
                    mins, maxs = entity\GetCollisionBounds!
                    health = ceil( mins\Distance( maxs ) * ( materials[ entity\GetMaterialType! or 0 ] or 1 ) )
                    cache[ entity\GetModel! ] = health

                entity\SetHealth( health )
                entity\SetMaxHealth( health )
                entity.CustomHealth = true
            else
                entity.CustomHealth = false

        unless entity.CustomHealth
            return

        health = max( 0, entity\Health! - damageInfo\GetDamage! )
        if health < 1
            velocity = entity\GetVelocity! + damageInfo\GetDamageForce!
            if entity\PrecacheGibs! > 0
                entity\GibBreakClient( velocity )

            dropModels = dropList[ entity\GetModel! ]
            if dropModels ~= nil
                count = dropModels.Count
                if istable( count )
                    count = random( count[ 1 ], count[ 2 ] )
                elseif not isnumber( count )
                    count = 1

                dropModels = dropModels.Models
                isTable = istable( dropModels )
                if isTable or isstring( dropModels )
                    mins, maxs = entity\GetCollisionBounds!
                    speed = velocity\Length!

                    mins *= 0.8
                    maxs *= 0.8

                    for i = 1, count
                        prop = Create( "prop_physics" )

                        if isTable
                            prop\SetModel( dropModels[ random( 1, #dropModels ) ] )
                        else
                            prop\SetModel( dropModels )

                        prop\SetPos( entity\LocalToWorld( Vector( random( mins[ 1 ], maxs[ 1 ] ), random( mins[ 2 ], maxs[ 2 ] ), random( mins[ 3 ], maxs[ 3 ] ) ) ) )
                        prop\SetAngles( Angle( random( -180, 180 ), random( -180, 180 ), random( -180, 180 ) ) )
                        prop\Spawn!

                        phys = prop\GetPhysicsObject!
                        if IsValid( phys )
                            phys\ApplyForceCenter( Vector( random( -1, 1 ), random( -1, 1 ), random( -1, 1 ) ) * speed )

            entity\Remove!
            return true

        entity\SetHealth( health )

        if ( health / entity\GetMaxHealth! ) > 0.5
            return

        changed = false
        if entity\GetMoveType! ~= MOVETYPE_VPHYSICS
            entity\SetMoveType( MOVETYPE_VPHYSICS )
            changed = true

        if entity\GetClass! == "prop_dynamic"
            entity\PhysicsInit( SOLID_VPHYSICS )
            changed = true

        phys = entity\GetPhysicsObject!
        if phys and phys\IsValid!
            unless phys\IsMotionEnabled!
                phys\EnableMotion( true )
                changed = true

            if phys\IsAsleep!
                phys\Wake!

        if changed
            entity\DoElectricSparks( entity\WorldSpaceCenter! )
            entity\EmitSound( "physics/metal/metal_box_break" .. random( 1, 2 ) .. ".wav", 70, random( 80, 120 ), 1, CHAN_STATIC, 0, 1 )

do

    player_old_armor = GetConVar( "player_old_armor" )

    GM.PerformArmorDamage = ( entity, armor, damageInfo ) =>
        if armor <= 0
            return 0

        if damageInfo\IsNonPhysicalDamage!
            return armor

        if damageInfo\IsCloseRangeDamage! and damageInfo\GetAttacker! == entity
            damageInfo\ScaleDamage( 0.25 )

        isEnabled = player_old_armor\GetBool!

        -- Each Point of Armor is worth 1/x points of health
        flBonus = isEnabled and 0.5 or 1

        -- Armor Takes 80% of the damage
        flRatio = 0.2

        damage = damageInfo\GetDamage!
        flNew = damage * flRatio
        flArmor = ( damage - flNew ) * flBonus

        if not isEnabled and flArmor < 1
            flArmor = 1

        if flArmor > armor
            flArmor = armor * ( 1 / flBonus )
            flNew = damage - flArmor
            armor = 0
        else
            armor -= flArmor

        damageInfo\SetDamage( flNew )
        return armor

do

    BLOOD_COLOR_MECH = BLOOD_COLOR_MECH
    BLOOD_COLOR_RED = BLOOD_COLOR_RED

    GM.HandlePlayerArmorReduction = ( ply, damageInfo ) =>
        ply\SetArmor( @PerformArmorDamage( ply, ply\Armor!, damageInfo ) )
        ply\SetBloodColor( ply\Armor! > 0 and BLOOD_COLOR_MECH or BLOOD_COLOR_RED )

GM.GetFallDamage = ( ply, speed ) =>
    if ply\GetNW2Bool( "in-flight" )
        return 0

    return max( 0, ceil( 0.2418 * speed - 141.75 ) )

do

    vector_origin = vector_origin
    LocalToWorld = LocalToWorld
    :BloodSplashes = Jailbreak

    GM.RagdollTakeDamage = ( ragdoll, damageInfo ) =>
        unless damageInfo\GetInflictor!\IsValid!
            damageInfo\SetDamageForce( vector_origin )

        if damageInfo\IsCrushDamage!
            damageInfo\ScaleDamage( 0.25 )

        armor = ragdoll.Armor
        if armor ~= nil and armor > 0
            ragdoll.Armor = @PerformArmorDamage( ragdoll, armor, damageInfo )

        if damageInfo\IsExplosionDamage!
            damageInfo\ScaleDamage( 0.25 )
        else
            damageInfo\ScaleDamage( 0.025 )

        damageInfo\SetDamage( ceil( damageInfo\GetDamage! ) )

        health = ragdoll\Health!
        nextHealth = floor( health - damageInfo\GetDamage! )
        ragdoll\SetHealth( nextHealth )

        if ragdoll\Alive!
            startHealth = ragdoll.StartHealth
            unless startHealth
                startHealth = health
                ragdoll.StartHealth = startHealth

            if ( nextHealth / startHealth ) < 0.75
                ragdoll\EmitSound( "Player.Death", 75, random( 80, 120 ), 1, CHAN_STATIC, 0, 1 )
                ragdoll\SetAlive( false )
                Run( "RagdollDeath", ragdoll )

        if nextHealth > 0
            BloodSplashes( ragdoll, damageInfo, false )
            return

        velocity = ragdoll\GetVelocity! + damageInfo\GetDamageForce!
        BloodSplashes( ragdoll, damageInfo, true, velocity )

        if ragdoll.Weapons ~= nil
            origin, angles = ragdoll\WorldSpaceCenter!, ragdoll\GetAngles!
            mins, maxs = ragdoll\GetCollisionBounds!
            mins, maxs = mins * 0.5, maxs * 0.5

            for weapon in *ragdoll.Weapons
                unless weapon\IsValid!
                    continue

                weapon\SetParent!
                weapon\SetNoDraw( false )
                weapon\SetNotSolid( false )

                origin, angles = LocalToWorld( Vector( random( mins[ 1 ], maxs[ 1 ], random( mins[ 2 ], maxs[ 2 ] ), random( mins[ 3 ], maxs[ 3 ] ) ) ), Angle( Rand( -90, 90 ), Rand( -180, 180 ), Rand( -180, 180 ) ), origin, angles )
                weapon\SetAngles( angles )
                weapon\SetPos( origin )

                phys = weapon\GetPhysicsObject!
                if IsValid( phys )
                    phys\SetVelocity( velocity )
                    phys\Wake!

                weapon.PickupForbidden = nil

            ragdoll.Weapons = nil

        if ragdoll\PrecacheGibs! > 0
            ragdoll\GibBreakClient( velocity )
        elseif random( 1, 2 ) == 1
            ragdoll\EmitSound( "physics/body/body_medium_break" .. random( 2, 4 ) .. ".wav", 70, random( 80, 120 ), 1, CHAN_STATIC, 0, 1 )
        else
            ragdoll\EmitSound( "physics/flesh/flesh_squishy_impact_hard" .. random( 1, 4 ) .. ".wav", 70, random( 80, 120 ), 1, CHAN_STATIC, 0, 1 )

        ragdoll\Remove!
