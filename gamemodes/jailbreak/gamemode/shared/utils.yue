Jailbreak = Jailbreak
GetGlobal2Int = GetGlobal2Int
:ceil, :max = math
CurTime = CurTime
:GetAll = player
NULL = NULL

TEAM_PRISONER = TEAM_PRISONER
TEAM_GUARD = TEAM_GUARD

do

    guardsDiff = Jailbreak.GuardsDiff
    :Joinable = team

    -- Returns true if team is joinable
    Jailbreak.TeamIsJoinable = ( requestedTeamID ) ->
            unless Joinable( requestedTeamID )
                return false

            guardCount, prisonerCount = 0, 0
            for ply in *GetAll!
                teamID = ply\Team!
                if teamID == TEAM_GUARD
                    guardCount += 1
                elseif teamID == TEAM_PRISONER
                    prisonerCount += 1

            switch requestedTeamID
                when TEAM_PRISONER
                    if prisonerCount == 0
                        return true

                    return guardCount ~= 0

                when TEAM_GUARD
                    if guardCount == 0
                        return true

                    if prisonerCount == 0
                        return false

                    return guardCount < ceil( prisonerCount / guardsDiff\GetInt! )

            return true

Jailbreak.GetWeaponName = =>
    unless @ and @IsValid! and @IsWeapon!
        return "#jb.unknown"

    printName = @GetPrintName!
    if printName == "Scripted Weapon"
        printName = "#" .. @GetClass!

    return printName

-- Returns fixed model path
do

    :gsub, :lower = string

    Jailbreak.FixModelPath = ( modelPath ) ->
        return gsub( lower( modelPath ), "[\\/]+", "/" )

-- Getting player count in team
Jailbreak.GetPlayersCount = ( teamID, alive ) ->
    count = 0
    for ply in *GetAll!
        if teamID ~= nil and ply\Team! ~= teamID
            continue

        if alive ~= nil and ply\Alive! ~= alive
            continue

        count += 1

    return count

do

    ipairs = ipairs

    -- Getting players in teams
    Jailbreak.GetTeamPlayers = ( alive, ... ) ->
        teams, players = { ... }, GetAll!
        for index, teamID in ipairs( teams )
            tbl, length = {}, 0

            for ply in *players
                if ply\Team! ~= teamID
                    continue

                if alive ~= nil and ply\Alive! ~= alive
                    continue

                length += 1
                tbl[ length ] = ply

            teams[ index ] = tbl

        return teams

    -- Getting player count in teams
    Jailbreak.GetTeamPlayersCount = ( alive, ... ) ->
        teams, players = { ... }, GetAll!
        for index, teamID in ipairs( teams )
            count = 0
            for ply in *players
                if ply\Team! ~= teamID
                    continue

                if alive ~= nil and ply\Alive! ~= alive
                    continue

                count += 1

            teams[ index ] = count

        return teams

do

    -- Returns warden as player
    getWarden = ->
        warden = Jailbreak.Warden
        if warden and warden\IsValid! and warden\IsWarden! and warden\Alive!
            return warden

        for ply in *GetAll!
            if ply\IsWarden!
                Jailbreak.Warden = ply
                return ply

        return NULL

    Jailbreak.GetWarden = getWarden

    -- Returns true if warden is exists
    Jailbreak.HasWarden = ->
        warden = getWarden!
        return warden\IsValid! and warden\Alive!

-- Round states
do

    ROUND_WAITING_PLAYERS = ROUND_WAITING_PLAYERS
    ROUND_PREPARING = ROUND_PREPARING
    ROUND_RUNNING = ROUND_RUNNING
    ROUND_ENDED = ROUND_ENDED

    -- Returns round state as integer
    getRoundState = ->
        return GetGlobal2Int( "round-state" )

    Jailbreak.GetRoundState = getRoundState

    -- Returns true if game is waiting players
    Jailbreak.IsWaitingPlayers = =>
        return getRoundState! == ROUND_WAITING_PLAYERS

    -- Returns true if round is preparing
    Jailbreak.IsRoundPreparing = =>
        return getRoundState! == ROUND_PREPARING

    -- Returns true if round is running
    Jailbreak.IsRoundRunning = =>
        return getRoundState! == ROUND_RUNNING

    -- Returns true if round is ended
    Jailbreak.IsRoundEnded = =>
        return getRoundState! == ROUND_ENDED

    -- Returns true if game is in progress
    Jailbreak.GameInProgress = =>
        state = getRoundState!
        return state ~= ROUND_WAITING_PLAYERS and state ~= ROUND_PREPARING

do

    -- Returns round time as integer
    getRoundTime = ->
        return GetGlobal2Int( "next-round-state" )

    Jailbreak.GetRoundTime = getRoundTime

    -- Returns round remaining time
    Jailbreak.GetRemainingTime = =>
        return max( 0, getRoundTime! - CurTime! )

-- Returns winning team index
Jailbreak.GetWinningTeam = ->
    return GetGlobal2Int( "winning-team" )

-- Returns true if shock collars are active
Jailbreak.IsShockCollarsActive = ->
    return GetGlobal2Bool( "shock-collars" )

-- Returns warden coins as integer
Jailbreak.GetWardenCoins = ->
    return GetGlobal2Int( "warden-coins" )

-- Returns true if female prison is enabled
Jailbreak.IsFemalePrison = ->
    return GetGlobal2Bool( "female-prison" )

ENTITY, PLAYER = FindMetaTable( "Entity" ), FindMetaTable( "Player" )
:GetNW2Bool, :GetNW2Entity, :GetNW2Var, :GetNW2Int = ENTITY

-- Returns true if player is jailbreak developer
PLAYER.IsDeveloper = =>
    return GetNW2Bool( @, "is-developer" )

-- Returns entity health
CHealth = ENTITY.CHealth
unless CHealth
    CHealth = ENTITY.Health
    ENTITY.CHealth = CHealth

PLAYER.Health = PLAYER.Health or CHealth

ENTITY.Health = =>
    return GetNW2Int( @, "health", CHealth( @ ) )

SetCHealth = ENTITY.SetCHealth
unless SetCHealth
    SetCHealth = ENTITY.SetHealth
    ENTITY.SetCHealth = SetCHealth

PLAYER.SetHealth = PLAYER.SetHealth or SetCHealth

-- Sets entity health
do

    :SetNW2Int = ENTITY

    ENTITY.SetHealth = ( int ) =>
        SetCHealth( @, int )
        if @IsPlayer!
            return

        SetNW2Int( @, "health", int )

-- Returns true if entity is using security radio
PLAYER.UsingSecurityRadio = =>
    return GetNW2Bool( @, "using-security-radio" )

-- Returns true if entity is player ragdoll
ENTITY.IsPlayerRagdoll = =>
    return GetNW2Bool( @, "is-player-ragdoll" )

-- Returns ragdoll owner
ENTITY.GetRagdollOwner = =>
    return GetNW2Entity( @, "ragdoll-owner" )

ENTITY.GetRagdollOwnerNickname = =>
    value = GetNW2Var( @, "owner-nickname" )
    unless value
        return "#jb.player.unknown"

    return value

-- Returns true if entity is under water
do

    :WaterLevel = ENTITY

    ENTITY.IsUnderwater = =>
        return WaterLevel( @ ) == 3

do

    -- Returns player color as vector
    getPlayerColor = nil
    do

        :DefaultPlayerColor = Jailbreak
        :GetNW2Vector = ENTITY

        getPlayerColor = =>
            return GetNW2Vector( @, "player-color", DefaultPlayerColor )

        ENTITY.GetPlayerColor = getPlayerColor

    -- Returns entity custom color
    do

        PLAYER_GetPlayerColor = PLAYER.GetPlayerColor
        :ToColor = FindMetaTable( "Vector" )

        ENTITY.GetModelColor = =>
            return ToColor( @IsPlayer! and PLAYER_GetPlayerColor( @ ) or getPlayerColor( @ ) )

        ENTITY.GetModelColorUnpacked = =>
            vector = @IsPlayer! and PLAYER_GetPlayerColor( @ ) or getPlayerColor( @ )
            return vector[ 1 ] * 255, vector[ 2 ] * 255, vector[ 3 ] * 255, 255


-- Sets player color
do

    :SetNW2Var = ENTITY

    ENTITY.SetPlayerColor = ( vector ) =>
        SetNW2Var( @, "player-color", vector )

-- Returns true if entity is prop
do

    classNames = list.GetForEdit( "prop-classnames" )
    classNames.prop_physics_multiplayer = true
    classNames.prop_physics_override = true
    classNames.prop_dynamic_override = true
    classNames.prop_dynamic = true
    classNames.prop_ragdoll = true
    classNames.prop_physics = true
    classNames.prop_detail = true
    classNames.prop_static = true

    Jailbreak.IsProp = ( className ) ->
        return classNames[ className ]

    ENTITY.IsProp = =>
        return classNames[ @GetClass! ]

-- Returns true if entity is button
ENTITY.IsButton = =>
    return GetNW2Bool( @, "is-button" )

-- Returns true if entity is food
ENTITY.IsFood = =>
    return GetNW2Bool( @, "is-food" )

-- Returns player team color
do

    DefaultColor = Color( 255, 255, 100, 255 )
    TeamInfo = team.GetAllTeams!

    getTeamColor = ( teamID ) ->
        teamInfo = TeamInfo[ teamID ]
        if teamInfo ~= nil
            return teamInfo.Color

        return DefaultColor

    Jailbreak.GetTeamColor = getTeamColor

    getTeamColorUpacked = ( teamID ) ->
        color = getTeamColor( teamID )
        return color.r, color.g, color.b, color.a

    Jailbreak.GetTeamColorUpacked = getTeamColorUpacked

    :Team = PLAYER

    PLAYER.GetTeamColor = =>
        return getTeamColor( Team( @ ) )

    PLAYER.GetTeamColorUpacked = =>
        return getTeamColorUpacked( Team( @ ) )

-- Returns true if player is fully connected
PLAYER.IsFullyConnected = =>
    return GetNW2Bool( @, "fully-connected" )

-- Returns weapons in slot as table
PLAYER.GetWeaponsInSlot = ( slot ) =>
    weapons = {}
    for weapon in *@GetWeapons!
        if weapon\GetSlot! == slot
            weapons[] = weapon

    return weapons

-- Returns true if player has weapons in slot
PLAYER.HasWeaponsInSlot = ( slot ) =>
    for weapon in *@GetWeapons!
        if weapon\GetSlot! == slot
            return true

    return false

-- Returns count of weapons in slot
PLAYER.GetCountWeaponsInSlot = ( slot ) =>
    count = 0
    for weapon in *@GetWeapons!
        if weapon\GetSlot! == slot
            count += 1

    return count

-- Returns player ragdoll as entity
do

    :FindByClass = ents

    PLAYER.GetRagdollEntity = =>
        value = GetNW2Entity( @, "player-ragdoll" )
        if value\IsValid!
            return value

        isBot = @IsBot!
        sid64 = isBot and @Nick! or @SteamID64!

        for entity in *FindByClass( "prop_ragdoll" )
            if entity\IsPlayerRagdoll! and entity\GetNW2Var( isBot and "owner-nickname" or "owner-steamid64" ) == sid64
                @SetNW2Entity( "player-ragdoll", entity )
                return entity

        for entity in *FindByClass( "prop_physics" )
            if entity\IsPlayerRagdoll! and entity\GetNW2Var( isBot and "owner-nickname" or "owner-steamid64" ) == sid64
                @SetNW2Entity( "player-ragdoll", entity )
                return entity

        return NULL

-- Returns true if player is guard
PLAYER.IsGuard = =>
    return @Team! == TEAM_GUARD

-- Returns true if player is prisoner
PLAYER.IsPrisoner = =>
    return @Team! == TEAM_PRISONER

-- Returns true if player is warden
PLAYER.IsWarden = =>
    return GetNW2Bool( @, "is-warden" )

-- Returns true if player has shock collar
PLAYER.HasShockCollar = =>
    return GetNW2Bool( @, "shock-collar" )

-- Returns true if player has security access
PLAYER.HasSecurityAccess = =>
    return GetNW2Bool( @, "security-access" )

-- Returns true if player has security radio
PLAYER.HasSecurityRadio = =>
    return GetNW2Bool( @, "security-radio" )

-- Returns table of players near player by distance
do

    :FindInSphere = ents

    PLAYER.GetNearPlayers = ( distance, isTeam, noSpeaker ) =>
        teamID = false
        if isTeam
            teamID = @Team!

        players = {}
        for ply in *FindInSphere( @EyePos!, distance )
            unless ply\IsPlayer!
                continue

            if noSpeaker and ply == @
                continue

            if isTeam and ply\Team! ~= teamID
                continue

            players[] = ply

        return players

do

    :KeyDown = PLAYER
    IN_USE = IN_USE

    PLAYER.GetUsedEntity = =>
        if KeyDown( @, IN_USE )
            return @GetUseEntity!

        return NULL

    PLAYER.IsUsingEntity = =>
        if KeyDown( @, IN_USE )
            entity = @GetUseEntity!
            return entity ~= NULL and entity\IsValid!

        return false

    PLAYER.GetUseTime = =>
        unless KeyDown( @, IN_USE )
            return 0

        startUseTime = GetNW2Int( @, "start-use-time" )
        if startUseTime == 0
            return 0

        return CurTime! - startUseTime

-- Silly spark sounds
do

    sounds = {}

    for number = 1, 6 do
        sounds[ number ] = "ambient/energy/spark" .. number .. ".wav"

    sound.Add {
        name: "Jailbreak.Shock"
        channel: CHAN_WEAPON
        level: SNDLVL_70dB
        sound: sounds
        pitch: 100
        volume: 1
    }

-- FUCK WIDGETS
hook.Remove "PostDrawEffects", "RenderWidgets"
hook.Remove "PlayerTick", "TickWidgets"
