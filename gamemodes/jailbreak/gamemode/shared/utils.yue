Jailbreak = Jailbreak

GetGlobal2Int = GetGlobal2Int
:ceil, :min, :max = math
:Run, :Add = hook
CurTime = CurTime
:GetAll = player
:Simple = timer
NULL = NULL

TEAM_SPECTATOR = TEAM_SPECTATOR
TEAM_PRISONER = TEAM_PRISONER
TEAM_GUARD = TEAM_GUARD

do

    guardsDiff = Jailbreak.GuardsDiff
    :Joinable = team

    -- Returns true if team is joinable
    Jailbreak.TeamIsJoinable = ( requestedTeamID ) ->
            unless Joinable( requestedTeamID )
                return false

            guardCount, prisonerCount = 0, 0
            for ply in *GetAll!
                teamID = ply\Team!
                if teamID == TEAM_GUARD
                    guardCount += 1
                elseif teamID == TEAM_PRISONER
                    prisonerCount += 1

            switch requestedTeamID
                when TEAM_PRISONER
                    if prisonerCount == 0
                        return true

                    return guardCount ~= 0

                when TEAM_GUARD
                    if guardCount == 0
                        return true

                    if prisonerCount == 0
                        return false

                    return guardCount < ceil( prisonerCount / guardsDiff\GetInt! )

            return true

do

    CLIENT = CLIENT
    GetPhrase = CLIENT and language.GetPhrase

    Jailbreak.GetWeaponName = ( weapon ) ->
        unless weapon and weapon\IsValid! and weapon\IsWeapon!
            return "#jb.unknown"

        if CLIENT
            placeholder = "jb." .. weapon\GetClass!
            if GetPhrase( placeholder ) ~= placeholder
                return "#" .. placeholder

        printName = weapon\GetPrintName!
        if printName == "Scripted Weapon"
            printName = "#" .. weapon\GetClass!

        return printName

-- Returns fixed model path
do

    :gsub, :lower = string

    Jailbreak.FixModelPath = ( modelPath ) ->
        return gsub( lower( modelPath ), "[\\/]+", "/" )

-- Getting player count in team
Jailbreak.GetPlayersCount = ( teamID, alive ) ->
    count = 0
    for ply in *GetAll!
        if teamID ~= nil and ply\Team! ~= teamID
            continue

        if alive ~= nil and ply\Alive! ~= alive
            continue

        count += 1

    return count

do

    ipairs = ipairs

    -- Getting players in teams
    Jailbreak.GetTeamPlayers = ( alive, ... ) ->
        teams, players = { ... }, GetAll!
        for index, teamID in ipairs( teams )
            tbl, length = {}, 0

            for ply in *players
                if ply\Team! ~= teamID
                    continue

                if alive ~= nil and ply\Alive! ~= alive
                    continue

                length += 1
                tbl[ length ] = ply

            teams[ index ] = tbl

        return teams

    -- Getting player count in teams
    Jailbreak.GetTeamPlayersCount = ( alive, ... ) ->
        teams, players = { ... }, GetAll!
        for index, teamID in ipairs( teams )
            count = 0
            for ply in *players
                if ply\Team! ~= teamID
                    continue

                if alive ~= nil and ply\Alive! ~= alive
                    continue

                count += 1

            teams[ index ] = count

        return teams

do

    -- Returns warden as player
    getWarden = ->
        warden = Jailbreak.Warden
        if warden and warden\IsValid! and warden\IsWarden! and warden\Alive!
            return warden

        for ply in *GetAll!
            if ply\IsWarden!
                Jailbreak.Warden = ply
                return ply

        return NULL

    Jailbreak.GetWarden = getWarden

    -- Returns true if warden is exists
    Jailbreak.HasWarden = ->
        warden = getWarden!
        return warden\IsValid! and warden\Alive!

-- Round states
do

    ROUND_WAITING_PLAYERS = ROUND_WAITING_PLAYERS
    ROUND_PREPARING = ROUND_PREPARING
    ROUND_RUNNING = ROUND_RUNNING
    ROUND_FINISHED = ROUND_FINISHED

    -- Returns round state as integer
    getRoundState = ->
        return GetGlobal2Int( "round-state" )

    Jailbreak.GetRoundState = getRoundState

    -- Returns true if game is waiting players
    Jailbreak.IsWaitingPlayers = =>
        return getRoundState! == ROUND_WAITING_PLAYERS

    -- Returns true if round is preparing
    Jailbreak.IsRoundPreparing = =>
        return getRoundState! == ROUND_PREPARING

    -- Returns true if round is running
    Jailbreak.IsRoundRunning = =>
        return getRoundState! == ROUND_RUNNING

    -- Returns true if round is finished
    Jailbreak.IsRoundFinished = =>
        return getRoundState! == ROUND_FINISHED

    -- Returns true if game is in progress
    Jailbreak.GameInProgress = =>
        state = getRoundState!
        return state ~= ROUND_WAITING_PLAYERS and state ~= ROUND_PREPARING

do

    -- Returns round time as integer
    getRoundTime = ->
        return GetGlobal2Int( "next-round-state" )

    Jailbreak.GetRoundTime = getRoundTime

    -- Returns round remaining time
    Jailbreak.GetRemainingTime = =>
        return max( 0, getRoundTime! - CurTime! )

-- Returns winning team index
Jailbreak.GetWinningTeam = ->
    return GetGlobal2Int( "winning-team" )

-- Returns true if shock collars are active
Jailbreak.IsShockCollarsActive = ->
    return GetGlobal2Bool( "shock-collars" )

do

    -- Returns warden coins as integer
    getWardenCoins = ->
        return GetGlobal2Int( "warden-coins" )

    Jailbreak.GetWardenCoins = getWardenCoins

    -- Returns true if warden player can afford to buy
    Jailbreak.CanWardenAfford = ( value ) ->
        return getWardenCoins! >= value

-- Returns true if female prison is enabled
Jailbreak.IsFemalePrison = ->
    return GetGlobal2Bool( "female-prison" )

-- Delayed entity remove
Jailbreak.DelayedRemove = ( delay ) =>
    Simple delay or 0, ->
        if @IsValid!
            @Remove!

-- Returns converted tf2 teams to jailbreak teams
Jailbreak.TF2Team = ( teamID ) ->
    switch teamID
        when 2
            return TEAM_PRISONER

        when 3
            return TEAM_GUARD

    return TEAM_SPECTATOR

ENTITY, PLAYER = FindMetaTable( "Entity" ), FindMetaTable( "Player" )
:GetNW2Bool, :GetNW2Entity, :GetNW2Var, :GetNW2Int = ENTITY

-- Returns true if player is jailbreak developer
PLAYER.IsDeveloper = =>
    return GetNW2Bool( @, "is-developer" )

-- Returns entity health
CHealth = ENTITY.CHealth
unless CHealth
    CHealth = ENTITY.Health
    ENTITY.CHealth = CHealth

PLAYER.Health = PLAYER.Health or CHealth

ENTITY.Health = =>
    return GetNW2Int( @, "health", CHealth( @ ) )

SetCHealth = ENTITY.SetCHealth
unless SetCHealth
    SetCHealth = ENTITY.SetHealth
    ENTITY.SetCHealth = SetCHealth

PLAYER.SetHealth = PLAYER.SetHealth or SetCHealth

-- Sets entity health
do

    :SetNW2Int = ENTITY

    ENTITY.SetHealth = ( int ) =>
        SetCHealth( @, int )
        if @IsPlayer!
            return

        SetNW2Int( @, "health", int )

-- Returns true if entity is using security radio
PLAYER.UsingSecurityRadio = =>
    return GetNW2Bool( @, "using-security-radio" )

-- Returns true if entity is player ragdoll
ENTITY.IsPlayerRagdoll = =>
    return GetNW2Bool( @, "is-player-ragdoll" )

-- Returns ragdoll owner
ENTITY.GetRagdollOwner = =>
    return GetNW2Entity( @, "ragdoll-owner" )

ENTITY.GetRagdollOwnerNickname = =>
    value = GetNW2Var( @, "owner-nickname" )
    unless value
        return "#jb.player.unknown"

    return value

-- Returns true if entity is under water
do

    :WaterLevel = ENTITY

    ENTITY.IsUnderwater = =>
        return WaterLevel( @ ) == 3

do

    getCTable = ENTITY.GetCTable
    if getCTable == nil
        getCTable = ENTITY.GetTable
        ENTITY.GetCTable = getCTable

    cache = {}

    Add "EntityRemove", "Jailbreak::EntityTableCache", =>
        Simple 0, ->
            cache[ @ ] = nil

    getTable = =>
        result = cache[ @ ]
        if result == nil
            result = getCTable( @ ) or {}
            cache[ @ ] = result

        return result

    ENTITY.GetTable = getTable

    PLAYER.__index = ( key ) =>
        value = PLAYER[ key ]
        if value == nil
            value = ENTITY[ key ]
            if value == nil
                return getTable( @ )[ key ]

        return value

    WEAPON = FindMetaTable( "Weapon" )

    WEAPON.__index = ( key ) =>
        value = WEAPON[ key ]
        if value == nil
            value = ENTITY[ key ]
            if value == nil
                return getTable( @ )[ key ]

        return value

do

    :DefaultPlayerColor = Jailbreak

    -- Returns player color as vector
    getPlayerColor = =>
        return @m_bPlayerColorVector or DefaultPlayerColor

    ENTITY.GetPlayerColor, PLAYER.GetPlayerColor = getPlayerColor, getPlayerColor

do

    isvector = isvector

    Add "EntityNetworkedVarChanged", "Jailbreak::PlayerColor", ( key, _, value ) =>
        if key == "player-color" and isvector( value )
            @m_bPlayerColorVector = value
            Run( "PlayerColorChanged", @, value )
            return

do

    :Call = hook

    do

        :ClearMovement, :ClearButtons = FindMetaTable( "CUserCmd" )

        Add "StartCommand", "Jailbreak::MovementBlocking", ( cmd ) =>
            if Call( "AllowPlayerMove", nil, @ ) == false
                ClearMovement( cmd )
                ClearButtons( cmd )

    do

        :GetVelocity, :SetVelocity = FindMetaTable( "CMoveData" )
        FrameTime = FrameTime
        Lerp = Lerp

        velocity, frameTime = vector_origin, 0

        Add "Move", "Jailbreak::MovementBlocking", ( mv ) =>
            if Call( "AllowPlayerMove", nil, @ ) == false
                velocity, frameTime = GetVelocity( mv ), FrameTime!
                velocity[ 1 ] = Lerp( frameTime, velocity[ 1 ], 0 )
                velocity[ 2 ] = Lerp( frameTime, velocity[ 2 ], 0 )
                SetVelocity( mv, velocity )

-- Returns entity custom color
do

    :ToColor = FindMetaTable( "Vector" )
    defaultColor = ToColor( Jailbreak.DefaultPlayerColor )

    Add "PlayerColorChanged", "Jailbreak::PlayerColor", ( vector ) =>
        @m_bPlayerColor = ToColor( vector )

    ENTITY.GetModelColor = =>
        if @IsValid!
            return @m_bPlayerColor or defaultColor

        return defaultColor

    ENTITY.GetModelColorUnpacked = =>
        if @IsValid!
            color = @m_bPlayerColor or defaultColor
            return color.r, color.g, color.b

        return defaultColor.r, defaultColor.g, defaultColor.b

-- Sets player color
do

    :SetNW2Vector = ENTITY

    setPlayerColor = ( vector ) =>
        SetNW2Vector( @, "player-color", vector )

    ENTITY.SetPlayerColor, PLAYER.SetPlayerColor = setPlayerColor, setPlayerColor

-- Returns true if entity is prop
do

    classNames = list.GetForEdit( "prop-classnames" )
    classNames.prop_physics_multiplayer = true
    classNames.prop_physics_override = true
    classNames.prop_dynamic_override = true
    classNames.prop_dynamic = true
    classNames.prop_ragdoll = true
    classNames.prop_physics = true
    classNames.prop_detail = true
    classNames.prop_static = true

    Jailbreak.IsProp = ( className ) ->
        return classNames[ className ] ~= nil

    :GetClass = ENTITY

    ENTITY.IsProp = =>
        return classNames[ GetClass( @ ) ] ~= nil

    :GetModel = ENTITY

    paintCans = {
        "models/props_junk/metal_paintcan001a.mdl": true
    	"models/props_junk/metal_paintcan001b.mdl": true
    }

    ENTITY.IsPaintCan = =>
        return classNames[ GetClass( @ ) ] ~= nil and paintCans[ GetModel( @ ) ] ~= nil

-- Returns true if entity is button
ENTITY.IsButton = =>
    return GetNW2Bool( @, "is-button" )

-- Returns true if entity is food
ENTITY.IsFood = =>
    return GetNW2Bool( @, "is-food" )

-- Returns player team
ENTITY.Team = =>
    return GetNW2Int( @, "player-team", TEAM_SPECTATOR )

ENTITY.Alive = =>
    return GetNW2Bool( @, "alive" ) and @Health! >= 1

-- Returns player team color
do

    DefaultColor = Color( 255, 255, 100, 255 )
    TeamInfo = team.GetAllTeams!

    getTeamColor = ( teamID ) ->
        teamInfo = TeamInfo[ teamID ]
        if teamInfo ~= nil
            return teamInfo.Color

        return DefaultColor

    Jailbreak.GetTeamColor = getTeamColor

    getTeamColorUpacked = ( teamID ) ->
        color = getTeamColor( teamID )
        return color.r, color.g, color.b, color.a

    Jailbreak.GetTeamColorUpacked = getTeamColorUpacked

    :Team = PLAYER

    PLAYER.GetTeamColor = =>
        return getTeamColor( Team( @ ) )

    PLAYER.GetTeamColorUpacked = =>
        return getTeamColorUpacked( Team( @ ) )

-- Returns true if player is fully connected
PLAYER.IsFullyConnected = =>
    return GetNW2Bool( @, "fully-connected" )

-- Returns true if player is flight allowed
PLAYER.IsFlightAllowed = =>
    return GetNW2Bool( @, "flight-allowed" )

-- Returns weapons in slot as table
PLAYER.GetWeaponsInSlot = ( slot ) =>
    weapons = {}
    for weapon in *@GetWeapons!
        if weapon\GetSlot! == slot
            weapons[] = weapon

    return weapons

-- Returns true if player has weapons in slot
PLAYER.HasWeaponsInSlot = ( slot ) =>
    for weapon in *@GetWeapons!
        if weapon\GetSlot! == slot
            return true

    return false

-- Returns count of weapons in slot
PLAYER.GetCountWeaponsInSlot = ( slot ) =>
    count = 0
    for weapon in *@GetWeapons!
        if weapon\GetSlot! == slot
            count += 1

    return count

-- Returns player ragdoll as entity
PLAYER.GetRagdollEntity = =>
    return GetNW2Entity( @, "player-ragdoll" )

do

    :FindByClass = ents

    PLAYER.FindRagdollEntity = =>
        entity = GetNW2Entity( @, "player-ragdoll" )
        if entity\IsValid!
            return entity

        isBot = @IsBot!
        sid64 = isBot and @Nick! or @SteamID64!

        for entity in *FindByClass( "prop_ragdoll" )
            if entity\IsPlayerRagdoll! and entity\GetNW2Var( isBot and "owner-nickname" or "owner-steamid64" ) == sid64
                @SetNW2Entity( "player-ragdoll", entity )
                return entity

        for entity in *FindByClass( "prop_physics" )
            if entity\IsPlayerRagdoll! and entity\GetNW2Var( isBot and "owner-nickname" or "owner-steamid64" ) == sid64
                @SetNW2Entity( "player-ragdoll", entity )
                return entity

        return NULL

-- Returns true if player is guard
PLAYER.IsGuard = =>
    return @Team! == TEAM_GUARD

-- Returns true if player is prisoner
PLAYER.IsPrisoner = =>
    return @Team! == TEAM_PRISONER

-- Returns true if player is warden
PLAYER.IsWarden = =>
    return GetNW2Bool( @, "is-warden" )

do

    -- Returns true if player has shock collar
    hasShockCollar = =>
        return GetNW2Bool( @, "shock-collar" )

    PLAYER.HasShockCollar = hasShockCollar

    -- Returns true if player shock collar is enabled
    PLAYER.ShockCollarIsEnabled = =>
        unless hasShockCollar( @ )
            return false

        return GetNW2Bool( @, "shock-collar-enabled" )

-- Returns true if player has security access
PLAYER.HasSecurityKeys = =>
    return GetNW2Bool( @, "security-keys" )

-- Returns true if player has security radio
PLAYER.HasSecurityRadio = =>
    return GetNW2Bool( @, "security-radio" )

-- Returns table of players near player by distance
do

    :FindInSphere = ents

    PLAYER.GetNearPlayers = ( distance, isTeam, noSpeaker ) =>
        teamID = false
        if isTeam
            teamID = @Team!

        players = {}
        for ply in *FindInSphere( @EyePos!, distance )
            unless ply\IsPlayer!
                continue

            if noSpeaker and ply == @
                continue

            if isTeam and ply\Team! ~= teamID
                continue

            players[] = ply

        return players

do

    :KeyDown = PLAYER
    IN_USE = IN_USE

    PLAYER.GetUsedEntity = =>
        if KeyDown( @, IN_USE )
            return @GetUseEntity!

        return NULL

    PLAYER.IsUsingEntity = =>
        if KeyDown( @, IN_USE )
            entity = @GetUseEntity!
            return entity ~= NULL and entity\IsValid!

        return false

    PLAYER.IsHoldingEntity = =>
        entity = @GetEntityInUse!
        return entity ~= NULL and entity\IsValid!

    PLAYER.GetUseTime = =>
        unless KeyDown( @, IN_USE )
            return 0

        startUseTime = GetNW2Int( @, "start-use-time" )
        if startUseTime == 0
            return 0

        return CurTime! - startUseTime

do

    :GetAmmoCount = PLAYER
    :GetAmmoMax = game

    getAmmoMax = ( ammoType ) ->
        return max( 0, min( 256, GetAmmoMax( ammoType ) ) )

    Jailbreak.GetAmmoMax = getAmmoMax

    PLAYER.GetPickupAmmoCount = ( ammoType ) =>
        return max( 0, getAmmoMax( ammoType ) - GetAmmoCount( @, ammoType ) )

do

    :PlayerSpawnTime = Jailbreak

    getAliveTime = =>
        return CurTime! - @GetSpawnTime!

    PLAYER.GetAliveTime = getAliveTime

    PLAYER.IsSpawning = =>
        return getAliveTime( @ ) <= PlayerSpawnTime\GetFloat!

-- Silly spark sounds
do

    sounds = {}

    for number = 1, 6 do
        sounds[ number ] = "ambient/energy/spark" .. number .. ".wav"

    sound.Add {
        name: "Jailbreak.ElectricSpark"
        channel: CHAN_WEAPON
        level: SNDLVL_70dB
        sound: sounds
        pitch: 100
        volume: 1
    }

-- FUCK WIDGETS
hook.Remove "PostDrawEffects", "RenderWidgets"
hook.Remove "PlayerTick", "TickWidgets"
