AddCSLuaFile( "shared.lua" )
AddCSLuaFile( "ui.lua" )
include( "shared.lua" )
Jailbreak = Jailbreak

global NOTIFY_GENERIC = 0
global NOTIFY_ERROR = 1
global NOTIFY_UNDO = 2
global NOTIFY_HINT = 3
global NOTIFY_CLEANUP = 4

ROUND_WAITING_PLAYERS = ROUND_WAITING_PLAYERS
ROUND_PREPARING = ROUND_PREPARING
ROUND_RUNNING = ROUND_RUNNING
ROUND_ENDED = ROUND_ENDED

TEAM_PRISONER = TEAM_PRISONER
TEAM_GUARD = TEAM_GUARD

ConVarFlags = bit.bor( FCVAR_ARCHIVE, FCVAR_NOTIFY )
CreateConVar = CreateConVar

GM.PrepareTime = CreateConVar( "jb_prepare_time", "10", ConVarFlags, "The time before the start of the round that is given for preparation.", 5, 2 * 60 * 60 )
GM.RoundTime = CreateConVar( "jb_round_time", "0", ConVarFlags, "Round time in seconds.", 0, 12 * 60 * 60 )

GM.PlayerRespawnTime = CreateConVar( "jb_respawn_time", "2", ConVarFlags, "Time to respawn players after death during preparation.", 0, 300 )
GM.DoorsHealth = CreateConVar( "jb_doors_health", "500", ConVarFlags, "The value is responsible for the health of the door.", 50, 10000 )
GM.GuardsArmor = CreateConVar( "jb_guards_armor", "0", ConVarFlags, "Guards armor amount on spawn.", 0, 1000 )

GM.PrisonerKnifeChance = CreateConVar( "jb_prisoner_knife_chance", "10", ConVarFlags, "Percentage value at which a prisoner can have a knife on spawn.", 0, 100 )

Classic = Jailbreak.Classic\GetBool!
cvars.AddChangeCallback( "jb_classic", ( _, __, value ) ->
    Classic = value == "1"
"Jailbreak" )

util.AddNetworkString( "Jailbreak::Networking" )

resource.AddWorkshop( "3093227948" )
resource.AddWorkshop( "2950445307" )
resource.AddWorkshop( "2661291057" )
resource.AddWorkshop( "643148462" )

math, table, team = math, table, team
:Effect, :IsValidModel, :IsInWorld, :TraceHull, :ScreenShake = util
team_NumPlayers, team_GetPlayers = team.NumPlayers , team.GetPlayers
:Create, :FindByClass, :FindInSphere = ents
:Rand, :random, :max, :min, :sqrt = math
:Empty, :Random, :Shuffle = table
player_GetAll = player.GetAll
timer_Simple = timer.Simple
hook_Run = hook.Run
tonumber = tonumber
istable = istable
CurTime = CurTime
IsValid = IsValid
Vector = Vector
ipairs = ipairs
string = string

colors = Jailbreak.Colors
:white = colors

do

    SetGlobal2Bool = SetGlobal2Bool
    SetGlobal2Int = SetGlobal2Int

    Jailbreak.SetRoundState = ( state, silent ) ->
        oldState = Jailbreak.GetRoundState!
        SetGlobal2Int( "round-state", state )
        unless silent
            hook_Run( "RoundStateChanged", oldState, state )

    Jailbreak.SetWinningTeam = ( teamID ) ->
        if Jailbreak.Teams[ teamID ]
            team.AddScore( teamID, 1 )
        SetGlobal2Int( "winning-team", teamID )

    Jailbreak.SetRoundTime = ( int ) ->
        SetGlobal2Int( "next-round-state", CurTime! + int )

    Jailbreak.SetFemalePrison = ( bool ) ->
        if bool == Jailbreak.IsFemalePrison!
            return

        SetGlobal2Bool( "female-prison", bool )

    Jailbreak.SetShockCollars = ( bool, silent ) ->
        if bool == Jailbreak.IsShockCollarsActive!
            return

        SetGlobal2Bool( "shock-collars", bool )

        unless silent
            hook_Run( "ShockCollars", bool )

    Jailbreak.SetWardenCoins = ( value, silent ) ->
        oldValue = Jailbreak.GetWardenCoins!
        if value == oldValue
            return

        SetGlobal2Int( "warden-coins", value )

        unless silent
            hook_Run( "WardenCoins", oldValue, value )

    Jailbreak.SendChatText = ( target, ... ) ->
        net.Start( "Jailbreak::Networking" )
        net.WriteUInt( 3, 2 )
        net.WriteTable( { ... }, true )
        if target
            net.Send( target )
        else
            net.Broadcast!

do

    :char, :sub, :gsub, :gmatch, :find = string

    global language = language or {}

    GetPhrase = ( languageCode, placeholder ) ->
        phrases = language[ languageCode ]
        unless phrases
            return placeholder

        return phrases[ placeholder ] or placeholder

    language.GetPhrase = GetPhrase

    Add = ( languageCode, placeholder, fulltext ) ->
        phrases = language[ languageCode ]
        unless phrases
            phrases = {}
            language[ languageCode ] = phrases

        phrases[ placeholder ] = fulltext

    language.Add = Add

    do

        parseUnicode = nil
        do

            :bor, :band, :rshift = bit
            tonumber = tonumber

            parseUnicode = ( str ) ->
                return gsub str, "\\u([0-9a-f][0-9a-f][0-9a-f][0-9a-f])", ( value ) ->
                    byte = tonumber( value, 16 )
                    if byte < 0x80 -- Single-byte sequence
                        return char( byte )
                    elseif byte < 0x800 -- Two-byte sequence
                        b1 = bor( 0xC0, band( rshift( byte, 6 ), 0x1F ) )
                        b2 = bor( 0x80, band( byte, 0x3F ) )
                        return char( b1, b2 )
                    elseif byte < 0x10000 -- Three-byte sequence
                        b1 = bor( 0xE0, band( rshift( byte, 12 ), 0x0F ) )
                        b2 = bor( 0x80, band( rshift( byte, 6 ), 0x3F ) )
                        b3 = bor( 0x80, band( byte, 0x3F ) )
                        return char( b1, b2, b3 )
                    else -- Four-byte sequence
                        b1 = bor( 0xF0, band( rshift( byte, 18 ), 0x07 ) )
                        b2 = bor( 0x80, band( rshift( byte, 12 ), 0x3F ) )
                        b3 = bor( 0x80, band( rshift( byte, 6 ), 0x3F ) )
                        b4 = bor( 0x80, band( byte, 0x3F ) )
                        return char( b1, b2, b3, b4 )

        string.ParseUnicode = parseUnicode

        parseEscapedChars = nil
        do

            escapedChars = {
                ["\\n"]: "\n"
                ["\\t"]: "\t"
                ["\\0"]: "\0"
            }

            parseEscapedChars = ( str ) ->
                return gsub str, "\\.", ( value ) ->
                    escapedChars[ value ] or value[ 2 ]

        string.ParseEscapedChars = parseEscapedChars

        Jailbreak.LoadLocalization = ( folderPath ) ->
            for languageCode in *select( 2, file.Find( folderPath .. "/*", "GAME" ) )
                for fileName in *file.Find( folderPath .. "/" .. languageCode .. "/*.properties", "GAME" )
                    file.AsyncRead folderPath .. "/" .. languageCode .. "/" .. fileName, "GAME", ( _, __, status, data ) ->
                        if status ~= 0
                            return

                        if not data or #data < 3
                            return

                        for line in gmatch( data, "(.-)\n" )
                            if #line >= 3
                                separatorPos = find( line, "=" )
                                unless separatorPos
                                    continue

                                Add( languageCode, sub( line, 1, separatorPos - 1 ), parseEscapedChars( parseUnicode( sub( line, separatorPos + 1 ) ) ) )

        concommand.Add "jb_reload_localization", =>
            if IsValid( @ ) and not @IsListenServerHost!
                return

            Jailbreak.LoadLocalization "gamemodes/jailbreak/content/resource/localization"
            Jailbreak.LoadLocalization "resource/localization"

    Jailbreak.Translate = ( str ) =>
        unless @IsValid! and @IsPlayer!
            return str

        languageCode = @GetInfo( "gmod_language" )
        if not languageCode and #languageCode < 2
            return str

        return gsub str, "#([%w%.-_]+)", ( placeholder ) ->
            fulltext = GetPhrase( languageCode, placeholder )
            if fulltext == placeholder and sub( placeholder, 1, 3 ) == "jb."
                return sub( placeholder, 4 )

            return fulltext

Jailbreak.SpectateTargets = Jailbreak.SpectateTargets or {}

GM.PostCleanupMap = =>
    targets = Jailbreak.SpectateTargets
    for key in pairs( targets )
        targets[ key ] = nil

Jailbreak.AddSpectateTarget = =>
    if IsValid( @ )
        Jailbreak.RemoveSpectateTarget( @ )
        Jailbreak.SpectateTargets[] = @

do

    :remove = table

    Jailbreak.RemoveSpectateTarget = =>
        for index, value in ipairs( Jailbreak.SpectateTargets )
            if value == @
                remove( Jailbreak.SpectateTargets, index )
                break

do

    ENTITY = FindMetaTable( "Entity" )

    ENTITY.IsSpectateTarget = =>
        if @IsPlayer! and @IsInGame!
            return true

        if @IsPlayerRagdoll!
            return true

        if Jailbreak.GameName == "tf" and @GetClass! == "info_observer_point"
            return true

        return false

do

    PLAYER = FindMetaTable( "Player" )

    PLAYER.SendPickupNotify = ( itemName ) =>
        net.Start( "Jailbreak::Networking" )
        net.WriteUInt( 1, 2 )
        net.WriteString( itemName )
        net.Send( @ )

    PLAYER.SendNotify = ( text, typeID, length, ... ) =>
        net.Start( "Jailbreak::Networking" )
        net.WriteUInt( 2, 2 )
        net.WriteString( text )
        net.WriteTable( { ... }, true )
        net.WriteUInt( typeID, 3 )
        net.WriteUInt( length, 16 )
        net.Send( @ )

    PLAYER.SetWarden = ( bool, silent ) =>
        if bool == @IsWarden!
            return

        @SetNW2Bool( "is-warden", bool )
        unless silent
            hook_Run( "WardenChanged", @, bool )

    PLAYER.SetShockCollar = ( bool, silent ) =>
        if bool == @HasShockCollar!
            return

        @SetNW2Bool( "shock-collar", bool )
        unless silent
            hook_Run( "ShockCollarChanged", @, bool )

    PLAYER.AllowSecurityAccess = ( bool ) =>
        @SetNW2Bool( "security-access", bool )

    PLAYER.AllowSecurityRadio = ( bool ) =>
        @SetNW2Bool( "security-radio", bool )

    PLAYER.MoveSpectateID = ( move, players ) =>
        targets = Jailbreak.SpectateTargets
        if #targets == 0
            return

        index, length = ( @LastSpectatedEntity or 0 ) + move, #targets
        if index > length
            index = 1
        elseif index < 1
            index = length

        entity = targets[ index ]
        if entity\IsPlayer! or entity\IsRagdoll!
            @SpectateEntity( entity )

            if @GetObserverMode! ~= OBS_MODE_CHASE
                @Spectate( OBS_MODE_CHASE )

        else

            if @GetObserverMode! ~= OBS_MODE_ROAMING
                @Spectate( OBS_MODE_ROAMING )

            @SetPos( entity\GetPos! )

            angles = entity\GetAngles!
            angles[ 3 ] = 0
            @SetEyeAngles( angles )

        @LastSpectatedEntity = index

    PLAYER.UsingSecurityRadio = =>
        return @HasSecurityRadio! and @GetInfo( "jb_security_radio" ) == "1"

    PLAYER.UsingMegaphone = =>
        return @IsWarden! and @GetInfo( "jb_megaphone" ) == "1"

    do

        WeaponHandlers = WeaponHandlers or {}
        NULL = NULL

        PLAYER.Give = ( className, noAmmo ) =>
            handler = WeaponHandlers[ className ]
            if handler
                className = handler.Alternative or className

            if @HasWeapon( className )
                return NULL

            weapon = Create( className )
            unless IsValid( weapon )
                return NULL

            weapon\SetAngles( @GetAngles! )
            weapon\SetPos( @GetPos! )

            weapon\Spawn!
            weapon\Activate!

            if weapon\IsWeapon!
                if noAmmo
                    weapon\SetClip1( 0 )
                    weapon\SetClip2( 0 )
                @PickupWeapon( weapon, false )
            return weapon

    PLAYER.SetMutedByWarden = ( bool ) =>
        @SetNW2Bool( "warden-mute", bool )

    PLAYER.RemoveRagdoll = =>
        ragdoll = @GetRagdollEntity!
        if ragdoll\IsValid!
            ragdoll\Remove!

    PLAYER.CreateClientsideRagdoll = PLAYER.CreateClientsideRagdoll or PLAYER.CreateRagdoll
    COLLISION_GROUP_PASSABLE_DOOR = COLLISION_GROUP_PASSABLE_DOOR
    NULL = NULL

    PLAYER.CreateServersideRagdoll = =>
        @RemoveRagdoll!

        modelPath = @GetModel!
        unless IsValidModel( modelPath )
            return NULL

        spawnOrigin = @WorldSpaceCenter!
        unless IsInWorld( spawnOrigin )
            return NULL

        ragdoll = Create( @GetBoneCount! > 1 and "prop_ragdoll" or "prop_physics" )
        ragdoll\SetAngles( @GetAngles! )
        ragdoll\SetModel( modelPath )
        ragdoll\SetPos( spawnOrigin )
        ragdoll\Spawn!

        ragdoll.Team = @Team!

        if @Alive!
            ragdoll.Alive = true
            ragdoll.PlayerAngles = @EyeAngles!

            ragdoll\SetMaxHealth( @GetMaxHealth! )
            ragdoll\SetHealth( @Health! )

            ragdoll.MaxArmor = @GetMaxArmor!
            ragdoll.Armor = @Armor!
        else
            ragdoll.Alive = false

        for bodygroup in *@GetBodyGroups!
            ragdoll\SetBodygroup( bodygroup.id, @GetBodygroup( bodygroup.id ) )

        ragdoll\SetFlexScale( @GetFlexScale! )
        for flexID = 0, @GetFlexNum!
            ragdoll\SetFlexWeight( flexID, @GetFlexWeight( flexID ) )

        ragdoll\SetPlayerColor( @GetPlayerColor! )
        ragdoll\SetMaterial( @GetMaterial! )
        ragdoll\SetColor( @GetColor! )
        ragdoll\SetSkin( @GetSkin! )

        for index = 1, #@GetMaterials!
            materialPath = @GetSubMaterial( index )
            if materialPath ~= ""
                ragdoll\SetSubMaterial( index, materialPath )

        ragdoll\SetCollisionGroup( COLLISION_GROUP_PASSABLE_DOOR )
        ragdoll\SetNW2Bool( "is-player-ragdoll", true )
        ragdoll\SetNW2Entity( "ragdoll-owner", @ )
        @SetNW2Entity( "player-ragdoll", ragdoll )

        unless @IsBot!
            ragdoll\SetNW2String( "owner-steamid64", @SteamID64! )
        ragdoll\SetNW2String( "owner-nickname", @Nick! )

        for boneID = 0, @GetBoneCount!
            ragdoll\ManipulateBonePosition( boneID, @GetManipulateBonePosition( boneID ) )
            ragdoll\ManipulateBoneAngles( boneID, @GetManipulateBoneAngles( boneID ) )
            ragdoll\ManipulateBoneJiggle( boneID, @GetManipulateBoneJiggle( boneID ) )
            ragdoll\ManipulateBoneScale( boneID, @GetManipulateBoneScale( boneID ) )

        if ragdoll\IsRagdoll!
            velocity = @LastMoveVelocity
            for physNum = 0, ragdoll\GetPhysicsObjectCount! - 1 do
                phys = ragdoll\GetPhysicsObjectNum( physNum )
                unless IsValid( phys )
                    continue

                boneID = ragdoll\TranslatePhysBoneToBone( physNum )
                if boneID < 0
                    continue

                origin, angles = @GetBonePosition( boneID )
                phys\SetVelocity( velocity )
                phys\SetAngles( angles )
                phys\SetPos( origin )
                phys\Wake!

        else
            phys = ragdoll\GetPhysicsObject!
            if IsValid( phys )
                phys\SetVelocity( @LastMoveVelocity )
                phys\Wake!

        if @IsOnFire!
            ragdoll\Ignite( 16, 64 )
            @Extinguish!

        hook_Run( "PlayerRagdollCreated", @, ragdoll )

        ragdoll.HasSecurityAccess = @HasSecurityAccess!
        ragdoll.HasSecurityRadio = @HasSecurityRadio!
        ragdoll.HasFlashlight = @CanUseFlashlight!
        ragdoll.HasShockCollar = @HasShockCollar!

        weapons = {}
        for weapon in *@GetWeapons!
            @DropWeapon( weapon )

            weapon\SetPos( spawnOrigin )
            weapon\SetParent( ragdoll )
            weapon\SetNotSolid( true )
            weapon\SetNoDraw( true )

            weapon.PickupForbidden = true
            weapons[] = weapon
        ragdoll.Weapons = weapons
        ragdoll.Ammo = @GetAmmo!

        Jailbreak.AddSpectateTarget( ragdoll )
        return ragdoll

    PLAYER.CreateRagdoll = PLAYER.CreateServersideRagdoll

GM.WardenChanged = ( ply, state ) =>
    Jailbreak.SendChatText( false, ply\GetPlayerColor!\ToColor!, ply\Nick!, white, state and " #jb.alert.warden_join" or " #jb.alert.warden_leave" )

GM.ShockCollarEffect = ( ply ) =>
    headBone, origin = ply\LookupBone( "ValveBiped.Bip01_Head1" ), nil
    if headBone and headBone >= 0
        matrix = ply\GetBoneMatrix( headBone )
        if matrix
            origin = matrix\GetTranslation!

    fx = EffectData!
    fx\SetScale( 0.5 )
    fx\SetOrigin( origin or ply\EyePos! )
    fx\SetMagnitude( random( 3, 5 ) )
    fx\SetRadius( random( 1, 5 ) )
    Effect( "ElectricSpark", fx )

    ply\EmitSound( "Jailbreak.Shock" )

GM.ShockCollars = ( bool ) =>
    for ply in *player_GetAll!
        if ply\Alive! and ply\HasShockCollar!
            Jailbreak.SendChatText( ply, bool and "#jb.notify.shock-collar.on" or "#jb.notify.shock-collar.off" )
            @ShockCollarEffect( ply )

GM.ShowTeam = ( ply ) =>
    ply\ConCommand( "jb_showteam" )

GM.PlayerInitialSpawn = ( ply, transiton ) =>
    ply.NextRespawnTime = 0

    if ply\IsBot!
        ply\SetTeam( TEAM_PRISONER )
    else
        ply\SetTeam( TEAM_SPECTATOR )
        ply.AvailableSpeakers = {}

    ragdoll = ply\GetRagdollEntity!
    if ragdoll\IsValid!
        ragdoll\SetNW2Entity( "ragdoll-owner", ply )
        ply\SetTeam( ragdoll.Team )
        ply.InitialSpawn = true

GM.SetupPlayerCollisions = ( ply ) =>
    if Jailbreak.GameName == "tf"
        ply\SetNoCollideWithTeammates( true )
        ply\SetAvoidPlayers( true )
    elseif ply\IsPrisoner!
        ply\SetNoCollideWithTeammates( false )
        ply\SetAvoidPlayers( true )
    else
        ply\SetNoCollideWithTeammates( true )
        ply\SetAvoidPlayers( false )

GM.MigrationPlayerFromRagdoll = ( ply, ragdoll ) =>
    if ragdoll.Alive and ragdoll\Health! > 1
        ply\SetEyeAngles( Angle( 0, ragdoll.PlayerAngles[ 2 ], 0 ) )
        ply\SetPos( ragdoll\WorldSpaceCenter! )
        ply\SetModel( ragdoll\GetModel! )

        ply\SetHealth( ply\GetMaxHealth! * ( ragdoll\Health! / ragdoll\GetMaxHealth! ) )
        ply\SetArmor( ply\GetMaxArmor! * ( ragdoll.Armor / ragdoll.MaxArmor ) )

        ply\SetPlayerColor( ragdoll\GetPlayerColor! )
        ply\SetMaterial( ragdoll\GetMaterial! )
        ply\SetColor( ragdoll\GetColor! )
        ply\SetSkin( ragdoll\GetSkin! )

        for bodygroup in *ply\GetBodyGroups!
            ply\SetBodygroup( bodygroup.id, ragdoll\GetBodygroup( bodygroup.id ) )

        for index = 1, #ply\GetMaterials!
            materialPath = ragdoll\GetSubMaterial( index )
            if materialPath ~= ""
                ply\SetSubMaterial( index, materialPath )

        if ragdoll\IsOnFire!
            ply\Ignite( 16, 16 )
            ragdoll\Extinguish!

        for boneID = 0, ply\GetBoneCount!
            ply\ManipulateBonePosition( boneID, ragdoll\GetManipulateBonePosition( boneID ) )
            ply\ManipulateBoneAngles( boneID, ragdoll\GetManipulateBoneAngles( boneID ) )
            ply\ManipulateBoneJiggle( boneID, ragdoll\GetManipulateBoneJiggle( boneID ) )
            ply\ManipulateBoneScale( boneID, ragdoll\GetManipulateBoneScale( boneID ) )

        if ragdoll\IsRagdoll!
            velocity = Vector!

            count = ragdoll\GetPhysicsObjectCount!
            for physNum = 0, count - 1
                phys = ragdoll\GetPhysicsObjectNum( physNum )
                if IsValid( phys )
                    velocity += phys\GetVelocity!

            velocity /= count
            ply\SetVelocity( velocity )
        else
            phys = ragdoll\GetPhysicsObject!
            if IsValid( phys )
                ply\SetVelocity( phys\GetVelocity! )

        ply\SetShockCollar( ragdoll.HasShockCollar == true )
        @SetupPlayerCollisions( ply )

        hook_Run( "PlayerRagdollUse", ragdoll, ply )

        ply\Give( "jb_hands" )
        ply\SelectWeapon( "jb_hands" )

        ply\SetupHands!
        ragdoll\Remove!
        return

    ply\KillSilent!

    timer_Simple 0, ->
        unless ply\IsValid! and ragdoll\IsValid!
            return

        ply\Spectate( OBS_MODE_CHASE )
        ply\SpectateEntity( ragdoll )

Jailbreak.PlayerWalkSpeed = CreateConVar( "jb_player_walk_speed", "220", ConVarFlags, "The speed of the player while walking.", 0, 3000 )
Jailbreak.PlayerRunSpeed = CreateConVar( "jb_player_run_speed", "280", ConVarFlags, "The speed of the player while running.", 0, 3000 )

GM.ClassicTeamColors = {
    [ TEAM_PRISONER ]: Vector( 0.62, 0.35, 0.07 )
    [ TEAM_GUARD ]: Vector( 0, 0, 0 )
}

do

    :Explode = string

    GM.PlayerSpawn = ( ply, transiton ) =>
        ply\DisableWorldClicking( true )
        ply\SetCanZoom( false )
        ply\SetWarden( false )
        ply\RemoveAllAmmo!
        ply\StripWeapons!
        ply\UnSpectate!

        if ply\FlashlightIsOn!
            ply\Flashlight( false )

        ply\SetSlowWalkSpeed( Jailbreak.PlayerSlowWalkSpeed\GetInt! )
        ply\SetWalkSpeed( Jailbreak.PlayerWalkSpeed\GetInt! )
        ply\SetRunSpeed( Jailbreak.PlayerRunSpeed\GetInt! )

        ply\SetMaxHealth( 100 )
        ply\SetMaxArmor( 100 )

        if ply.InitialSpawn ~= nil
            ply.InitialSpawn = nil

            ragdoll = ply\GetRagdollEntity!
            if ragdoll\IsValid!
                @MigrationPlayerFromRagdoll( ply, ragdoll )
                return

            if Jailbreak.GameInProgress!
                ply\KillSilent!
                return

        @SetupPlayerCollisions( ply )

        teamID = ply\Team!
        unless Jailbreak.Teams[ teamID ]
            ply\KillSilent!
            return

        if teamID == TEAM_GUARD
            ply\SetArmor( @GuardsArmor\GetInt! )
            ply\AllowSecurityAccess( true )
            ply\AllowSecurityRadio( true )
            ply\AllowFlashlight( true )
        else
            ply\AllowSecurityAccess( false )
            ply\AllowSecurityRadio( false )
            ply\AllowFlashlight( false )
            ply\SetArmor( 0 )

        ply\SetShockCollar( teamID == TEAM_PRISONER )
        ply\SetMaxArmor( max( 100, ply\Armor! ) )
        ply\SetHealth( 100 )
        ply\RemoveRagdoll!

        unless transiton
            hook_Run( "PlayerLoadout", ply, teamID )
        hook_Run( "PlayerSetModel", ply, teamID )

        if ply\IsBot!
            ply\SetPlayerColor( Vector( Rand( 0, 1 ), Rand( 0, 1 ), Rand( 0, 1 ) ) )
            ply\SetWeaponColor( Vector( Rand( 0, 1 ), Rand( 0, 1 ), Rand( 0, 1 ) ) )
            ply\SetSkin( random( 0, ply\SkinCount! ) )

            for bodygroup in *ply\GetBodyGroups!
                ply\SetBodygroup( bodygroup.id, random( 0, bodygroup.num - 1 ) )

        else
            ply\SetPlayerColor( Vector( ply\GetInfo( "cl_playercolor" ) ) )
            ply\SetSkin( ply\GetInfoNum( "cl_playerskin", 0 ) )

            weaponColor = Vector( ply\GetInfo( "cl_weaponcolor" ) )
            if weaponColor\Length! < 0.001
                weaponColor = Vector( 0.001, 0.001, 0.001 )
            ply\SetWeaponColor( weaponColor )

            groups = Explode( " ", ply\GetInfo( "cl_playerbodygroups" ) or "" )
            for i = 0, ply\GetNumBodyGroups! - 1 do
                ply\SetBodygroup( i, tonumber( groups[ i + 1 ] ) or 0 )

        if Classic
            ply\SetPlayerColor( @ClassicTeamColors[ teamID ] )

        hook_Run( "TeamPlayerSpawn", ply, teamID )
        ply\SetupHands!

GM.EntityRemoved = ( entity, fullUpdate ) =>
    if fullUpdate
        return

    if entity\IsSpectateTarget!
        Jailbreak.RemoveSpectateTarget( entity )
        return

GM.OnEntityCreated = ( entity ) =>
    if entity\IsPlayer!
        return

    -- Fuck givers
    if entity\GetClass! == "game_player_equip"
        entity\Remove!
        return

    if entity\IsSpectateTarget!
        Jailbreak.AddSpectateTarget( entity )
        return

    unless entity\IsWeapon!
        return

    timer_Simple 0.025, ->
        unless entity\IsValid!
            return

        if IsValid( entity\GetOwner! )
            return

        if entity\GetPos!\Length! <= 3
            entity\Remove!
            return

        entity\SetCollisionGroup( COLLISION_GROUP_WEAPON )

        phys = entity\GetPhysicsObject!
        unless IsValid( phys ) and phys\IsMotionEnabled!
            return

        counter = 0
        for other in *FindInSphere( entity\GetPos!, 32 )
            if other\IsWeapon! and not IsValid( other\GetOwner! )
                counter = counter + 1
                if counter >= 5
                    phys\EnableMotion( false )
                    return

do

    COLLISION_GROUP_DEBRIS = COLLISION_GROUP_DEBRIS

    GM.PlayerDroppedWeapon = ( ply, weapon ) =>
        timerName = "JB_WeaponDrop #" .. weapon\EntIndex!
        timer.Create timerName, 3, 1, ->
            timer.Remove( timerName )

            unless weapon\IsValid!
                return

            phys = weapon\GetPhysicsObject!
            unless IsValid( phys )
                return

            start = weapon\WorldSpaceCenter!
            mins, maxs = weapon\GetCollisionBounds!

            tr = TraceHull( {
                start: start
                endpos: start + Vector( 0, 0, mins[ 3 ] - 2 )
                mask: MASK_SOLID_BRUSHONLY
                mins: mins
                maxs: maxs
            } )

            if tr.Hit
                weapon\SetCollisionGroup( COLLISION_GROUP_DEBRIS )
                phys\EnableMotion( false )
                return

            @PlayerDroppedWeapon( ply, weapon )

do

    GM.GuardsAmmoMult = CreateConVar( "jb_guards_ammo", "1", ConVarFlags, "Guards ammo multiplier ( max * multiplier ) on spawn.", 0, 1000 )
    :GetAmmoTypes, :GetAmmoMax = game

    GM.PlayerLoadout = ( ply, teamID ) =>
        if teamID == TEAM_GUARD
            do
                mult = @GuardsAmmoMult\GetFloat!
                for index = 1, #GetAmmoTypes!
                    ply\GiveAmmo( min( 250, GetAmmoMax( index ) * mult ), index, true )

            if Jailbreak.GameName ~= "cstrike" and not @Medieval
                avaliableWeapons = @AvaliableWeapons
                count = #avaliableWeapons / 4
                gived = {}

                while count > 0
                    className = Random( avaliableWeapons )
                    if ply\HasWeapon( className ) or gived[ className ]
                        continue

                    gived[ className ] = true
                    ply\Give( className )
                    count -= 1
        elseif teamID == TEAM_PRISONER
            unless ply\HasWeapon( "weapon_knife" )
                if Classic
                    ply\Give( "weapon_knife" )
                    return
                elseif random( 1, 100 ) <= @PrisonerKnifeChance\GetInt!
                    ply\Give( "weapon_knife" )

        ply\Give( "jb_hands" )
        ply\SelectWeapon( "jb_hands" )

do

    :PrecacheModel = util
    :match = string

    GM.PlayerSetModel = ( ply, teamID ) =>
        requested = Jailbreak.FixModelPath( player_manager.TranslatePlayerModel( ply\GetInfo( "cl_playermodel" ) ) )
        if Jailbreak.CustomPlayerModels\GetBool! and IsValidModel( requested )
            PrecacheModel( requested )
            ply\SetModel( requested )
            return

        models = Jailbreak.PlayerModels[ teamID ][ Jailbreak.IsFemalePrison! ]
        if IsValidModel( requested )
            requestedName = match( requested, "([%w%_%-]+)%.mdl$" )
            for modelPath in *models
                if modelPath == requested or match( modelPath, "([%w%_%-]+)%.mdl$" ) == requestedName
                    ply\SetModel( modelPath )
                    return

        if #models == 1
            ply\SetModel( models[ 1 ] )
            return

        ply\SetModel( Random( models ) )

GM.PlayerSetHandsModel = ( ply, hands ) =>
    info = player_manager.TranslatePlayerHands( player_manager.TranslateToPlayerModelName( ply\GetModel! ) )
    unless info
        return

    hands\SetModel( info.model )
    hands\SetBodyGroups( info.body )
    hands\SetPlayerColor( ply\GetPlayerColor! )
    hands\SetSkin( info.matchBodySkin and ply\GetSkin! or info.skin )

do

    vector_origin = vector_origin
    :GetSpawnPoint = team

    GM.PlayerSelectSpawn = ( ply, transition ) =>
        if transiton
            return

        teamID = ply\Team!
        unless Jailbreak.Teams[ teamID ]
            teamID = random( 1, 2 )

        for className in *GetSpawnPoint( teamID )
            spawnPoints = FindByClass( className )
            unless spawnPoints
                continue

            length = #spawnPoints
            if length == 0
                continue

            if length ~= 1
                Shuffle( spawnPoints )

            killLength = length - length * 0.25

            for index = 1, length
                entity = spawnPoints[ index ]
                if entity\IsValid! and hook_Run( "IsSpawnpointSuitable", ply, entity, index >= killLength )
                    return entity

        ply\SetPos( vector_origin )

GM.IsSpawnpointSuitable = ( ply, entity, makeSuitable ) =>
    if entity\GetClass! == "info_player_teamspawn"
        if entity.Disabled or Jailbreak.TF2Team( entity.Team ) ~= ply\Team!
            return false

    mins, maxs = ply\GetHull!
    start = entity\GetPos!

    traceResult = TraceHull( {
        start: start
        endpos: start
        mask: MASK_PLAYERSOLID
        filter: entity
        mins: mins
        maxs: maxs
    } )

    unless traceResult.Hit
        return true

    traceEntity = traceResult.Entity
    unless traceEntity\IsValid!
        return true

    if traceEntity\IsPlayer! and traceEntity\Alive!
        if makeSuitable
            traceEntity\Kill!
            return true
        return false

    return true

GM.DoPlayerDeath = ( ply, attacker, damageInfo ) =>
    teamID = ply\Team!
    unless Jailbreak.Teams[ teamID ]
        return

    ply\AddDeaths( 1 )

    if attacker\IsValid! and attacker\IsPlayer! and attacker ~= ply
        attacker\AddFrags( 1 )

    ragdoll = ply\CreateServersideRagdoll!
    if ragdoll\IsValid!

        damageOrigin = damageInfo\GetDamagePosition!
        if ragdoll\IsRagdoll!
            velocity = damageInfo\GetDamageForce!
            for physNum = 0, ragdoll\GetPhysicsObjectCount! - 1 do
                phys = ragdoll\GetPhysicsObjectNum( physNum )
                if IsValid( phys )
                    phys\ApplyForceOffset( velocity / phys\GetMass!, damageOrigin )

        else
            phys = ragdoll\GetPhysicsObject!
            if IsValid( phys )
                phys\ApplyForceOffset( damageInfo\GetDamageForce! / phys\GetMass!, damageOrigin )

        timer_Simple 0, ->
            unless ply\IsValid! and ragdoll\IsValid!
                return

            ply\Spectate( OBS_MODE_CHASE )
            ply\SpectateEntity( ragdoll )

    hook_Run( "TeamPlayerDeath", ply, teamID )

GM.PlayerSilentDeath = ( ply ) =>
    teamID = ply\Team!
    if Jailbreak.Teams[ teamID ]
        hook_Run( "TeamPlayerDeath", ply, teamID )

do

    MovementKeys = bit.bor( IN_FORWARD, IN_BACK, IN_MOVELEFT, IN_MOVERIGHT, IN_JUMP )

    GM.SpectatorThink = ( ply ) =>
        observerMode = ply\GetObserverMode!
        if observerMode ~= OBS_MODE_ROAMING and observerMode ~= OBS_MODE_CHASE
            ply\Spectate( OBS_MODE_ROAMING )
        else
            if ply\KeyPressed( MovementKeys )
                if observerMode ~= OBS_MODE_ROAMING
                    eyeAngles = ply\EyeAngles!

                    ply\Spectate( OBS_MODE_ROAMING )
                    ply\SpectateEntity!

                    ply\SetEyeAngles( eyeAngles )

            elseif ply\KeyPressed( IN_ATTACK )
                ply\MoveSpectateID( 1 )
            elseif ply\KeyPressed( IN_ATTACK2 )
                ply\MoveSpectateID( -1 )

GM.PlayerDeathThink = ( ply ) =>
    if not Jailbreak.Teams[ ply\Team! ] or Jailbreak.GameInProgress!
        @SpectatorThink( ply )
        return

    if ply.NextRespawnTime > CurTime!
        return

    ply\Spawn!

GM.PlayerDisconnected = ( ply ) =>
    teamID = ply\Team!
    if Jailbreak.Teams[ teamID ]
        hook_Run( "TeamPlayerDisconnected", ply, teamID )

DMG_NEVERGIB = DMG_NEVERGIB

do

    GM.CloseRangeDamageTypes = { DMG_SLASH, DMG_FALL, DMG_CLUB, DMG_CRUSH }
    GM.ShockCollarVictimDamage = CreateConVar( "jb_shock_collar_victim_damage", "0.25", ConVarFlags, "Damage to the victim from the electric collar.", 0, 1000 )
    GM.ShockCollarAttackerDamage = CreateConVar( "jb_shock_collar_attacker_damage", "0.5", ConVarFlags, "Damage to the attacker from the electric collar.", 0, 1000 )
    :band = bit

    GM.PlayerTakeDamage = ( ply, damageInfo, teamID ) =>
        damageType = damageInfo\GetDamageType!
        if ply\HasShockCollar! and band( damageType, DMG_SHOCK ) == DMG_SHOCK
            ply\SetShockCollar( false )

        unless Jailbreak.IsShockCollarsActive!
            return

        attacker = damageInfo\GetAttacker!
        if attacker\IsValid! and attacker\IsPlayer! and attacker\HasShockCollar! and attacker ~= ply
            for int in *@CloseRangeDamageTypes
                if band( damageType, int ) == int
                    damage = damageInfo\GetDamage!

                    newDamage = damage * @ShockCollarAttackerDamage\GetFloat!
                    if newDamage >= 1
                        @ShockCollarEffect( attacker )
                        damageInfo\SetDamage( newDamage )
                        damageInfo\SetDamageType( DMG_SONIC )
                        attacker\TakeDamageInfo( damageInfo )

                    newDamage = damage * @ShockCollarVictimDamage\GetFloat!
                    if newDamage < 1
                        return true

                    damageInfo\SetDamageType( damageType )
                    damageInfo\SetDamage( newDamage )
                    break

GM.EntityTakeFireDamage = ( entity, damageInfo ) =>
    if entity\IsOnFire! and ( entity\WaterLevel! >= 2 or ( entity\IsPlayer! and not entity\IsInGame! ) )
        entity\Extinguish!
        return true

do

    :band = bit

    GM.EntityTakeDamage = ( entity, damageInfo ) =>
        if entity\IsPlayerRagdoll!
            return true

        if band( damageInfo\GetDamageType!, DMG_BURN ) == DMG_BURN and hook_Run( "EntityTakeFireDamage", entity, damageInfo ) == true
            return true

        if entity\IsPlayer!
            if entity\Alive!
                teamID = entity\Team!
                if hook_Run( "CanPlayerTakeDamage", entity, damageInfo, teamID ) ~= false
                    return hook_Run( "PlayerTakeDamage", entity, damageInfo, teamID )
            return true

        if band( damageInfo\GetDamageType!, DMG_NEVERGIB ) == DMG_NEVERGIB
            return

        switch entity\GetClass!
            when "prop_door_rotating"
                maxHealth = entity\GetMaxHealth!
                if maxHealth <= 1
                    maxHealth = @DoorsHealth\GetInt!
                    if maxHealth <= 0
                        return true

                    entity\SetHealth( maxHealth )
                    entity\SetMaxHealth( maxHealth )

                health = entity\Health!
                if health < 1
                    return true

                health = max( 0, health - damageInfo\GetDamage! )
                entity\SetHealth( health )

                if health > 1
                    return true

                model = entity\GetModel!
                unless model and #model ~= 0 and IsValidModel( model )
                    return true

                center = entity\OBBCenter!
                center[ 1 ] = 0
                center[ 2 ] = 0

                origin = entity\LocalToWorld( center )
                unless IsInWorld( origin )
                    return true

                prop = Create( "prop_physics" )
                prop\SetCollisionGroup( COLLISION_GROUP_WEAPON )
                prop\SetAngles( entity\GetAngles! )
                prop\SetSkin( entity\GetSkin! )
                prop\SetModel( model )
                prop\SetPos( origin )
                prop\Spawn!

                prop\EmitSound( "physics/wood/wood_crate_break" .. random( 1, 5 ) .. ".wav", 70, random( 80, 120 ), 1, CHAN_STATIC, 0, 1 )
                entity\Remove!

                phys = prop\GetPhysicsObject!
                if IsValid( phys )
                    phys\ApplyForceOffset( damageInfo\GetDamageForce!, damageInfo\GetDamagePosition! )

                origin = damageInfo\GetDamagePosition!
                fx = EffectData!
                fx\SetOrigin( origin )
                fx\SetMagnitude( 5 )
                fx\SetRadius( 5 )
                fx\SetScale( 2 )
                Effect( "Sparks", fx )
                ScreenShake( origin, 5, 10, 0.5, 150 )
                return true
            when "func_button"
                if band( damageInfo\GetDamageType!, DMG_BLAST ) == DMG_BLAST
                    return true

                attacker = damageInfo\GetAttacker!
                if attacker\IsValid! and attacker\IsPlayer! and random( 0, 1 ) == 1
                    entity\Use( attacker, attacker )
                    entity\EmitSound( "Jailbreak.Shock" )

                    fx = EffectData!
                    fx\SetScale( 0.5 )
                    fx\SetOrigin( entity\WorldSpaceCenter! )
                    fx\SetMagnitude( random( 3, 5 ) )
                    fx\SetRadius( random( 1, 5 ) )
                    Effect( "ElectricSpark", fx )

                return true

        if entity\GetNoDraw! or not entity\IsSolid!
            return

        velocity = damageInfo\GetDamageForce!
        for physNum = 0, entity\GetPhysicsObjectCount! - 1 do
            phys = entity\GetPhysicsObjectNum( physNum )
            if IsValid( phys )
                phys\ApplyForceOffset( velocity, damageInfo\GetDamagePosition! )

do

    :ceil = math

    GM.GetFallDamage = ( ply, speed ) =>
        return max( 0, ceil( 0.2418 * speed - 141.75 ) )

GM.PlayerShouldTaunt = ( ply ) =>
    return ply\IsInGame!

GM.AllowPlayerPickup = ( ply, entity ) =>
    return ply\IsInGame!

GM.PlayerCanPickupItem = ( ply, entity ) =>
    return ply\IsInGame!

GM.PlayerCanPickupWeapon = ( ply, weapon ) =>
    unless ply\IsInGame!
        return false

    if ply\HasWeapon( weapon\GetClass! )
        return false

    slot = weapon\GetSlot!
    if slot == 0 or slot == 5
        return true

    if ply\HasWeaponsInSlot( slot )
        return false

    if slot == 1 or slot == 4
        return true

    for i = 1, 2
        if ply\HasWeaponsInSlot( i + 1 )
            return false

    return true

GM.PlayerNoClip = ( ply, desiredState ) =>
    if desiredState
        return ply\IsInGame! and ply\IsSuperAdmin! and not ply\IsPlayingTaunt!
    return true

GM.CanPlayerSuicide = ( ply ) =>
    if Jailbreak.IsRoundPreparing!
        return false

    return ply\IsInGame!

GM.PlayerSwitchFlashlight = ( ply, newState ) =>
    return not newState or ( ( Classic or ply\CanUseFlashlight! ) and ply\Alive! )

GM.PlayerDeathSound = ( ply ) =>
    if Classic or ply\IsGuard!
        ply\EmitSound( "Player.Death", 75, random( 80, 120 ), 1, CHAN_VOICE, 0, 1 )
    return true

GM.PlayerRagdollUse = ( ragdoll, ply ) =>
    velocity = Vector!

    direction = ply\EyePos! - ragdoll\WorldSpaceCenter!
    direction\Normalize!

    unless Classic
        if ragdoll.HasFlashlight and not ply\CanUseFlashlight!
            velocity += direction * 150
            ply\AllowFlashlight( true )
            ply\SendPickupNotify( "jb.flashlight" )
            ragdoll.HasFlashlight = nil

        if ragdoll.HasSecurityAccess and not ply\HasSecurityAccess!
            velocity += direction * 50
            ply\AllowSecurityAccess( true )
            ply\SendPickupNotify( "jb.access-card" )
            ragdoll.HasSecurityAccess = nil

        if ragdoll.HasSecurityRadio and not ply\HasSecurityRadio!
            velocity += direction * 50
            ply\AllowSecurityRadio( true )
            ply\SendPickupNotify( "jb.walkie-talkie" )
            ragdoll.HasSecurityRadio = nil

    weapons = ragdoll.Weapons
    if istable( weapons )
        for weapon in *weapons
            unless weapon\IsValid! and not IsValid( weapon\GetOwner! )
                continue

            weapon\SetNotSolid( false )
            weapon\SetNoDraw( false )
            weapon\SetParent!

            weapon.PickupForbidden = nil
            ply\PickupWeapon( weapon )
            velocity += direction * 200
    ragdoll.Weapons = nil

    ammo = ragdoll.Ammo
    if istable( ammo )
        for ammoType, ammoCount in pairs( ammo )
            ply\GiveAmmo( ammoCount, ammoType )
            velocity += direction * 100
    ragdoll.Ammo = nil

    if velocity\Length! < 100
        return

    if ragdoll\IsRagdoll!
        physParts = {}
        for physNum = 1, ragdoll\GetPhysicsObjectCount! - 1 do
            phys = ragdoll\GetPhysicsObjectNum( physNum )
            if IsValid( phys )
                physParts[] = phys

        Shuffle( physParts )

        for index = 1, min( #physParts, 4 )
            physParts[ index ]\ApplyForceCenter( velocity )

    else
        phys = ragdoll\GetPhysicsObject!
        if IsValid( phys )
            phys\ApplyForceCenter( velocity )

GM.PlayerSpray = ( ply ) =>
    return not ( ply\IsInGame! and ( Classic or ply\IsPrisoner! ) )

GM.AmmoPickupBlacklist = {
    weapon_frag: true
}

GM.PlayerUse = ( ply, entity ) =>
    unless ply\IsInGame!
        return

    unless Classic
        weapon = ply\GetActiveWeapon!
        if IsValid( weapon ) and weapon\GetHoldType! == "fist" and entity\IsPlayer!
            velocity = ply\GetVelocity!\GetNormalized! * 16
            entity\SetVelocity( velocity )
            ply\SetVelocity( -velocity )
            return false

    curTime, lastUse = CurTime!, ply.LastUse or 0
    ply.LastUse = curTime

    if ( curTime - lastUse ) <= 0.025
        return

    if entity\IsPlayerRagdoll!
        hook_Run( "PlayerRagdollUse", entity, ply )
        return false

    if entity\IsWeapon!
        if entity.PickupForbidden
            return false

        if entity.IsTemporaryWeapon
            entity = entity\GetParent!
            unless entity\IsValid! and entity\IsWeapon!
                return false

        className = entity\GetClass!
        if ply\HasWeapon( className )
            if @AmmoPickupBlacklist[ className ]
                return false

            clip1, clip1Type = entity\Clip1!, entity\GetPrimaryAmmoType!
            if clip1 > 0 and clip1Type >= 0
                ply\GiveAmmo( clip1, clip1Type, false )
                entity\SetClip1( 0 )

            clip2, clip2Type = entity\Clip2!, entity\GetSecondaryAmmoType!
            if clip2 > 0 and clip2Type >= 0
                ply\GiveAmmo( clip2, clip2Type, false )
                entity\SetClip2( 0 )

            return false

        slot = entity\GetSlot!
        if slot > 0 and slot < 5
            if slot == 1 or slot == 4
                weapons = ply\GetWeaponsInSlot( slot )

                length = #weapons
                if length ~= 0
                    weapon = weapons[ length ]
                    if IsValid( weapon )
                        ply\DropWeapon( weapon )
            else
                for i = 1, 2
                    weapons = ply\GetWeaponsInSlot( i + 1 )

                    length = #weapons
                    if length ~= 0
                        weapon = weapons[ length ]
                        if IsValid( weapon )
                            ply\DropWeapon( weapon )

        if hook_Run( "PlayerCanPickupWeapon", ply, entity ) ~= false
            ply\PickupWeapon( entity, false )
            return false

    return true

do

    DistToSqr = FindMetaTable( "Vector" ).DistToSqr
    EyePos = FindMetaTable( "Entity" ).EyePos
    player_GetHumans = player.GetHumans
    RecipientFilter = RecipientFilter
    :Clamp, :Round = math
    net = net

    util.AddNetworkString( "JB::Voice Chat" )

    SendVolumes = ( listener, volumes ) ->
        net.Start( "JB::Voice Chat", true )
        net.WriteUInt( #volumes, 10 )
        for data in *volumes
            net.WriteEntity( data[ 1 ] )
            net.WriteFloat( data[ 2 ] )
        net.Send( listener )

    OOC = GetConVar( "sv_alltalk" )\GetInt! > 2
    cvars.AddChangeCallback( "sv_alltalk", ( _, __, value ) ->
        OOC = ( tonumber( value ) or 2 ) > 2
    "Jailbreak" )

    CanHear = ( listener, speaker ) ->
        if speaker\Alive!
            if speaker\IsMutedByWarden!
                return false, false
        else
            return not listener\Alive!, false

    timer.Create "JB:Voice Chat Think", 0.5, 0, ->
        players = player_GetHumans!
        for listener in *players
            speakers = listener.AvailableSpeakers
            Empty( speakers )
            volumes = {}

            if OOC or not Jailbreak.IsRoundRunning!
                for speaker in *players
                    volumes[] = { speaker, 1 }
                    speakers[ speaker ] = 1

                SendVolumes( listener, volumes )
                continue

            origin = EyePos( listener )

            rf = RecipientFilter!
            rf\AddPAS( origin )

            hasRadio = listener\HasSecurityRadio!
            listenerIndex = listener\EntIndex!

            for speaker in *rf\GetPlayers!
                if speaker\IsBot! or speaker\EntIndex! == listenerIndex
                    continue

                if CanHear( listener, speaker ) == false
                    continue

                if hasRadio and speaker\UsingSecurityRadio!
                    continue

                if speaker\UsingMegaphone!
                    volumes[] = { speaker, 1 }
                    speakers[ speaker ] = 1
                    continue

                volume = Round( 1 - Clamp( max( 0, DistToSqr( origin, EyePos( speaker ) ) - Jailbreak.VoiceChatMinDistance ) / Jailbreak.VoiceChatMaxDistance, 0, 1 ), 2 )
                if volume > 0
                    volumes[] = { speaker, volume }
                    speakers[ speaker ] = volume

            if hasRadio
                for speaker in *players
                    if speaker\UsingSecurityRadio!
                        volumes[] = { speaker, 1 }
                        speakers[ speaker ] = 1

            SendVolumes( listener, volumes )

    GM.PlayerCanSeePlayersChat = ( _, isTeam, listener, speaker ) =>
        if listener\IsBot!
            return

        unless IsValid( speaker )
            return true

        if isTeam and listener\Team! ~= speaker\Team!
            return false

        if speaker\UsingMegaphone!
            return true

        if OOC or not Jailbreak.IsRoundRunning!
            return true

        canHear = CanHear( listener, speaker )
        if canHear ~= nil
            return canHear

        return listener.AvailableSpeakers[ speaker ] ~= nil

    GM.PlayerCanHearPlayersVoice = ( listener, speaker ) =>
        if listener\EntIndex! == speaker\EntIndex! or listener\IsBot! or speaker\IsBot!
            return

        if OOC or not Jailbreak.IsRoundRunning!
            return true, false

        if speaker\UsingMegaphone!
            return true, true

        canHear, is3D = CanHear( listener, speaker )
        if canHear ~= nil
            return canHear, is3D

        if listener.AvailableSpeakers[ speaker ] ~= nil
            return true, not speaker\UsingSecurityRadio!

        return false, false

GM.PlayerRequestTeam = ( ply, teamID ) =>
    unless team.Joinable( teamID )
        return

    oldTeamID = ply\Team!
    if oldTeamID == teamID
        return

    unless Jailbreak.TeamIsJoinable( teamID )
        ply\SendNotify( "#jb.error.cant-do-that", NOTIFY_ERROR, 10 )
        return

    if ply\Alive!
        if Jailbreak.Teams[ oldTeamID ]
            ply\Kill!
        else
            ply\KillSilent!

    ply\SetTeam( teamID )

concommand.Add "drop", =>
    dropWeapon = @GetActiveWeapon!
    unless IsValid( dropWeapon )
        return

    model = dropWeapon\GetWeaponWorldModel!
    unless model and IsValidModel( model )
        return

    @DropWeapon( dropWeapon )

    maxWeight, nextWeapon = nil, nil
    for weapon in *@GetWeapons!
        weight = weapon\GetWeight!

        if not maxWeight or maxWeight <= weight
            nextWeapon = weapon
            maxWeight = weight

    unless IsValid( nextWeapon )
        return

    @SelectWeapon( nextWeapon\GetClass! )

do

    util.AddNetworkString( "Jailbreak::Markers" )
    :TraceLine = util
    :remove = table
    :sub = string

    concommand.Add "marker", =>
        unless Jailbreak.Markers\GetBool!
            return

        unless IsValid( @ ) and @Alive!
            return

        if @NextMarker and CurTime! < @NextMarker
            return

        isWarden, isPrisoner = @IsWarden!, @IsPrisoner!
        unless isWarden or isPrisoner
            @SendNotify( "#jb.error.cant-do-that", NOTIFY_ERROR, 10 )
            return

        distance = 0
        if isWarden
            distance = 32768
        elseif isPrisoner
            distance = sqrt( Jailbreak.VoiceChatMinDistance )

        @LagCompensation( true )

        traceResult = TraceLine( {
            start: @EyePos!
            endpos: @EyePos! + @GetAimVector! * distance
            filter: ( entity ) ->
                return entity ~= @ and not entity.IsTemporaryWeapon
            mask: MASK_SHOT
        } )

        @LagCompensation( false )

        unless traceResult.Hit
            return

        @NextMarker = CurTime! + ( Jailbreak.MarkersLifetime\GetInt! / Jailbreak.MarkersCount\GetInt! )

        entity = traceResult.Entity
        isValid = IsValid( entity )

        net.Start( "Jailbreak::Markers" )
        net.WriteEntity( @ )
        net.WriteBool( isValid )

        if isValid
            net.WriteEntity( entity )
            net.WriteVector( entity\WorldToLocal( traceResult.HitPos ) )
        else
            net.WriteVector( traceResult.HitPos )

        if isWarden
            net.Broadcast!
        elseif isPrisoner
            players, hasSender = @GetNearPlayers( distance, true ), false
            for index, ply in ipairs( players )
                if ply == @
                    hasSender = true
                    break

            unless hasSender
                players[] = @

            net.Send( players )

        if entity\IsValid!
            if entity\IsPlayer!
                Jailbreak.Emotion( @, "#jb.chat.pointed-at ", entity\GetPlayerColor!\ToColor!, entity\Nick!, white, "." )
            elseif entity\IsWeapon!
                printName = nil
                if entity\IsScripted!
                    printName = entity.PrintName

                if printName
                    printName = "#" .. printName
                else
                    printName = entity\GetPrintName!

                if printName == "Scripted Weapon"
                    printName = "#" .. entity\GetClass!

                Jailbreak.Emotion( @, "#jb.chat.pointed-at \"" .. printName .. "\"." )
            else
                Jailbreak.Emotion( @, "#jb.chat.pointed-at \"#jb." .. entity\GetClass! .. "\"." )

        else
            Jailbreak.Emotion( @, "#jb.chat.pointed-at \"#jb.world\"." )

GM.InitPostEntity = =>
    Jailbreak.LoadLocalization "gamemodes/jailbreak/content/resource/localization"
    Jailbreak.LoadLocalization "resource/localization"
    RunConsoleCommand( "sv_defaultdeployspeed", "1" )
    RunConsoleCommand( "mp_show_voice_icons", "0" )

    if #FindByClass( "info_player_teamspawn" ) ~= 0
        @Medieval = #FindByClass( "tf_logic_medieval" ) ~= 0
        resource.AddWorkshop( "105181283" )
        Jailbreak.GameName = "tf"
        SoundHandler( "tf" )
    elseif ( #FindByClass( "info_player_counterterrorist" ) + #FindByClass( "info_player_counterterrorist" ) ) ~= 0
        Jailbreak.GameName = "cstrike"
        SoundHandler( "cstrike" )

    Jailbreak.SetRoundState( ROUND_WAITING_PLAYERS )

GM.PlayerInitialized = ( ply ) =>
    gameName = Jailbreak.GameName
    unless gameName
        return

    net.Start( "Jailbreak::Networking" )
    net.WriteUInt( 0, 2 )
    net.WriteString( gameName )
    net.Send( ply )

GM.SetupMove = ( ply, _, cmd ) =>
    if ply\IsBot! or ply\IsFullyConnected! or not cmd\IsForced!
        return

    ply\SetNW2Bool( "fully-connected", true )
    hook_Run( "PlayerInitialized", ply )

GM.Think = =>
    if Jailbreak.GetRoundTime! <= CurTime!
        switch Jailbreak.GetRoundState!
            when ROUND_PREPARING
                Jailbreak.SetRoundState( ROUND_RUNNING )
            when ROUND_RUNNING
                if @RoundTime\GetInt! == 0
                    return

                team.AddScore( TEAM_GUARD, 1 )
                Jailbreak.SetWinningTeam( TEAM_GUARD )

                Jailbreak.SetRoundState( ROUND_ENDED, true )
                Jailbreak.SetRoundTime( @PrepareTime\GetInt! )
            when ROUND_ENDED
                Jailbreak.SetRoundState( ROUND_WAITING_PLAYERS )

include( "events.lua" )

GM.RoundStateChanged = ( old, new ) =>
    Jailbreak.RunEvents( new )

    switch ( new )
        when ROUND_WAITING_PLAYERS
            Jailbreak.SetShockCollars( false )

            for ply in *player_GetAll!
                if ply\IsInGame!
                    ply\KillSilent!

                if ply\IsBot! or ply\IsGuard!
                    ply\SetTeam( TEAM_PRISONER )

    		timer_Simple( 0, game.CleanUpMap )

        when ROUND_PREPARING
            Jailbreak.SetShockCollars( true )

            for ply in *player_GetAll!
                if ply\IsBot!
                    ply\SetTeam( TEAM_PRISONER )

                if Jailbreak.Teams[ ply\Team! ]
                    ply\Spawn!

    		timer_Simple( 0, game.CleanUpMap )

        when ROUND_RUNNING
            Jailbreak.SetShockCollars( true )

            guardCount, prisonerCount = team_NumPlayers( TEAM_GUARD ), team_NumPlayers( TEAM_PRISONER )
            totalCount = guardCount + prisonerCount

            while ( guardCount / prisonerCount ) > Jailbreak.GuardsDiff and totalCount > ( ( 1 / Jailbreak.GuardsDiff ) + guardCount )
                for i = 1, guardCount
                    guard = Random( team_GetPlayers( TEAM_GUARD ) )
                    if guard\IsValid!
                        guard\SetTeam( TEAM_PRISONER )
                        guard\Spawn!
                        break

                guardCount, prisonerCount = team_NumPlayers( TEAM_GUARD ), team_NumPlayers( TEAM_PRISONER )
                totalCount = guardCount + prisonerCount

            if guardCount == 0 or prisonerCount == 0
                Jailbreak.SetRoundState( ROUND_WAITING_PLAYERS )
                return

            for ply in *player_GetAll!
                if ply\IsBot!
                    for teamID = 1, 2
                        if Jailbreak.TeamIsJoinable( teamID )
                            ply\SetTeam( teamID )
                            break

                    ply\Spawn!

                else

                    teamID = ply\Team!
                    if teamID == TEAM_PRISONER
                        ply\SetShockCollar( true )

                    if Jailbreak.Teams[ teamID ] and not ply\Alive!
                        ply\Spawn!

            do

                guards = team_GetPlayers( TEAM_GUARD )
                guardCount = #guards

                if guardCount == 1
                    guards[ guardCount ]\SetWarden( true )

            roundTime = @RoundTime\GetInt!
            if roundTime > 0
                Jailbreak.SetRoundTime( roundTime )

        when ROUND_ENDED
            guardCount, prisonerCount = Jailbreak.GetTeamAliveCount( TEAM_GUARD ), Jailbreak.GetTeamAliveCount( TEAM_PRISONER )
            if guardCount > prisonerCount
                Jailbreak.SetWinningTeam( TEAM_GUARD )
            elseif guardCount < prisonerCount
                Jailbreak.SetWinningTeam( TEAM_PRISONER )
            else
                Jailbreak.SetWinningTeam( 0 )

            warden = Jailbreak.GetWarden!
            if IsValid( warden )
                warden\SetWarden( false, true )

            Jailbreak.SetRoundTime( @PrepareTime\GetInt! )

GM.TeamPlayerDeath = ( ply, teamID ) =>
    ply.NextRespawnTime = CurTime! + @PlayerRespawnTime\GetFloat!
    Jailbreak.RemoveSpectateTarget( ply )
    ply\UnSpectate!

    ply\AllowSecurityAccess( false )
    ply\AllowSecurityRadio( false )
    ply\AllowFlashlight( false )

    if ply\HasShockCollar!
        ply\SetShockCollar( false, true )

    isWarden = ply\IsWarden!
    if isWarden
        ply\SetWarden( false, true )

    if ply\FlashlightIsOn!
        ply\Flashlight( false )

    timer.Create "Jailbreak::TeamPlayerDeath", 0.5, 1, ->
        timer.Remove "Jailbreak::TeamPlayerDeath"

        state = Jailbreak.GetRoundState!
        if state == ROUND_PREPARING and team_NumPlayers( teamID ) == 0
            Jailbreak.SetRoundState( ROUND_WAITING_PLAYERS )
        elseif state == ROUND_RUNNING and Jailbreak.GetTeamAliveCount( teamID ) == 0
            Jailbreak.SetRoundState( ROUND_ENDED )

        if isWarden and Jailbreak.IsRoundRunning! and ply\IsValid!
            hook_Run( "WardenChanged", ply, false )

GM.TeamPlayerDisconnected = ( ply, teamID ) =>
    unless ply\Alive!
        return

    timer.Create "Jailbreak::TeamPlayerDisconnected", 0.5, 1, ->
        timer.Remove "Jailbreak::TeamPlayerDisconnected"
        unless Jailbreak.IsRoundRunning!
            return

        if Jailbreak.GetTeamAliveCount( TEAM_GUARD ) == 0 or Jailbreak.GetTeamAliveCount( TEAM_PRISONER ) == 0
            Jailbreak.SetRoundState( ROUND_ENDED )

    Jailbreak.RemoveSpectateTarget( ply)
    ply\CreateServersideRagdoll!

GM.TeamPlayerSpawn = ( ply ) =>
    if Jailbreak.IsWaitingPlayers! and Jailbreak.GetTeamAliveCount( TEAM_GUARD ) > 0 and Jailbreak.GetTeamAliveCount( TEAM_PRISONER ) > 0
        Jailbreak.SetRoundState( ROUND_PREPARING )
        Jailbreak.SetRoundTime( @PrepareTime\GetInt! )

    Jailbreak.AddSpectateTarget( ply )

concommand.Add "changeteam", ( _, args ) =>
    hook_Run( "PlayerRequestTeam", @, tonumber( args[ 1 ] ) )

concommand.Add "jb_warden", ( _, args ) =>
    unless IsValid( @ )
        return

    unless Jailbreak.IsRoundRunning! and @Alive! and @IsGuard!
        @SendNotify( "#jb.error.warden-failure", NOTIFY_ERROR, 10 )
        return

    if ( @WardenDelay or 0 ) > CurTime!
        @SendNotify( "#jb.please-wait", NOTIFY_ERROR, 3 )
        return

    if @IsWarden!
        @WardenDelay = CurTime! + 10
        @SetWarden( false )
        return

    if Jailbreak.HasWarden!
        @SendNotify( "#jb.error.warden-exists", NOTIFY_ERROR, 10 )
        return

    @WardenDelay = CurTime! + 5
    @SetWarden( true )

concommand.Add "jb_shock_collars", ( _, args ) =>
    unless IsValid( @ )
        return

    unless Jailbreak.IsRoundRunning! and @Alive! and @IsWarden!
        @SendNotify( "#jb.error.cant-do-that", NOTIFY_ERROR, 10 )
        return

    if ( @ShockCollarsDelay or 0 ) > CurTime!
        @SendNotify( "#jb.please-wait", NOTIFY_ERROR, 3 )
        return

    requested = args[ 1 ]
    if requested ~= nil and #requested ~= 0
        Jailbreak.SetShockCollars( requested == "1" )
    else
        Jailbreak.SetShockCollars( not Jailbreak.IsShockCollarsActive! )

    @ShockCollarsDelay = CurTime! + 5

do

    :lower, :find = string

    do

        replaceFilter = ( modelName, chance ) ->
            unless isnumber( chance )
                chance = nil

            if isstring( modelName )
                modelName = lower( modelName )
            elseif istable( modelName )
                tbl = {}
                for str in *modelName
                    tbl[ lower( str ) ] = true

                modelName = tbl
            else
                return =>
                    return not chance or random( 1, 100 ) <= chance

            return =>
                modelPath = @GetModel!
                unless modelPath
                    return false

                modelPath = lower( modelPath )
                unless IsValidModel( modelPath )
                    return false

                if istable( modelName )
                    unless modelName[ modelPath ]
                        return false
                else
                    unless find( modelPath, modelName, 1, false )
                        return false

                return not chance or random( 1, 100 ) <= chance

        do

            foodModels = {
                -- GMOD
                "models/food/burger.mdl"
                "models/food/hotdog.mdl"

                -- HL2
                "models/props_c17/doll01.mdl"
                "models/props_junk/garbage_glassbottle001a.mdl"
                "models/props_junk/garbage_glassbottle002a.mdl"
                "models/props_junk/garbage_glassbottle003a.mdl"
                "models/props_junk/garbage_milkcarton002a.mdl"
                "models/props_junk/garbage_milkcarton001a.mdl"
                "models/props_junk/garbage_plasticbottle003a.mdl"
                "models/props_junk/garbage_takeoutcarton001a.mdl"
                "models/props_junk/GlassBottle01a.mdl"
                "models/props_junk/glassjug01.mdl"
                "models/props_junk/watermelon01.mdl"
                "models/props_junk/Shoe001a.mdl"

                -- CSS
                "models/props/CS_militia/bottle01.mdl"
                "models/props/CS_militia/bottle02.mdl"
                "models/props/CS_militia/bottle03.mdl"
                "models/props/cs_office/Snowman_nose.mdl"
                "models/props/cs_office/trash_can_p8.mdl"
                "models/props/cs_office/Water_bottle.mdl"
                "models/props/cs_italy/bananna.mdl"
                "models/props/cs_italy/bananna_bunch.mdl"
                "models/props/cs_italy/banannagib1.mdl"
                "models/props/cs_italy/banannagib2.mdl"
                "models/props/cs_italy/orange.mdl"
                "models/props/cs_italy/orangegib1.mdl"
                "models/props/cs_italy/orangegib2.mdl"
                "models/props/cs_italy/orangegib3.mdl"
                "models/props/de_inferno/crate_fruit_break_gib1.mdl"
                "models/props/de_inferno/crate_fruit_break_gib2.mdl"
                "models/props/de_inferno/crate_fruit_break_gib3.mdl"
                "models/props/de_inferno/goldfish.mdl"
            }

            for index, modelPath in ipairs( foodModels )
                foodModels[ index ] = lower( modelPath )

            Jailbreak.FoodModels = foodModels
            Model = Model

            EntityReplacer "^prop_physics.*", "jb_food", replaceFilter( foodModels ), ( entity ) =>
                @SetModel( Model( entity\GetModel! ) )

                maxHealth = entity\GetMaxHealth!
                if maxHealth > 1
                    @SetMaxHealth( maxHealth )
                    @SetHealth( maxHealth )

        Addons = {

            -- https://steamcommunity.com/sharedfiles/filedetails/?id=293904092
            ["293904092"]: ->
                EntityReplacer "^prop_physics.*", "sent_soccerball", replaceFilter( "models/props_phx/misc/soccerball%.mdl" )

            -- https://steamcommunity.com/sharedfiles/filedetails/?id=931376012
            ["931376012"]: ->
                EntityReplacer "^prop_physics.*", "sent_jetpack", replaceFilter( "models/props_junk/%w+%.mdl", 2 ), =>
                    @SetSlotName( @GetClass! )

            -- https://steamcommunity.com/sharedfiles/filedetails/?id=931448005
            ["931448005"]: ->
                EntityReplacer "^prop_physics.*", "sent_grapplehook_bpack", replaceFilter( "models/props_junk/%w+%.mdl", 5 ), =>
                    @SetSlotName( @GetClass! )

                    timer_Simple 0, ->
                        if @IsValid!
                            @SetKey( 12 )

        }

        do
            fileName = "jailbreak/entity-replacer.json"
            if file.Exists( fileName, "DATA" )
                json = file.Read( fileName, "DATA" )
                if isstring( json )
                    data = util.JSONToTable( json )
                    if istable( data )
                        for key, value in pairs( data )
                            Addons[ key ] = ->
                                return EntityReplacer value[ 1 ], value[ 2 ], replaceFilter( value[ 3 ], value[ 4 ] )

            else
                file.Write( fileName, "[]" )

        global PropReplaceFilter = replaceFilter
        Jailbreak.Addons = Addons

        timer_Simple 0, ->
            for addon in *engine.GetAddons!
                unless addon.downloaded and addon.mounted
                    continue

                wsid = addon.wsid
                func = Addons[ wsid ]
                unless func
                    continue

                Jailbreak[ wsid ] = func( addon )

    do

        ChatCommands = Jailbreak.ChatCommands
        unless istable( ChatCommands )
            ChatCommands = {}
            Jailbreak.ChatCommands = ChatCommands

        Jailbreak.SetChatCommand = ( str, func ) ->
            ChatCommands[ lower( str ) ] = func

        :GetHumans = player
        :sub, :StartsWith = string

        GM.PlayerSay = ( ply, text, isTeam ) =>
            if Classic
                return text

            if StartsWith( text, "/" )
                _, endPos, command = find( text, "^/([^%s]+)" )
                if command
                    func = ChatCommands[ lower( command ) ]
                    if func
                        return func( ply, sub( text, min( endPos + 2, #text ) ) ) or ""

                return ""

            if isTeam
                ply\Say( text, false )
                return ""

            elseif ply\UsingSecurityRadio!
                players = {}
                for pl in *GetHumans!
                    if pl\HasSecurityRadio!
                        players[] = pl

                Jailbreak.SendChatText( players, "[#jb.walkie-talkie] ", ply\GetPlayerColor!\ToColor!, ply\Nick!, white, " #jb.chat.says: \"" .. text .. "\"" )
                Jailbreak.Whisper( ply, text )
                return ""

            unless Jailbreak.GameInProgress!
                Jailbreak.OOC( ply, text )
                return ""

            return text

    do

        WhisperDistance = CreateConVar( "jb_whisper_distance", "32", ConVarFlags, "", 16, 65536 )
        Jailbreak.WhisperDistance = WhisperDistance

        Whisper = ( text ) =>
            Jailbreak.SendChatText( @GetNearPlayers( WhisperDistance\GetInt!, false ), @GetPlayerColor!\ToColor!, @Nick!, white, " #jb.chat.whispers, \"" .. text .. "\"" )

        Jailbreak.Whisper = Whisper
        Jailbreak.SetChatCommand "w", Whisper
        Jailbreak.SetChatCommand "whisper", Whisper

    do

        :GetColor = team

        LOOC = ( text ) =>
            Jailbreak.SendChatText( @GetNearPlayers( sqrt( Jailbreak.VoiceChatMinDistance ), false ), colors.blue, "[#jb.chat.looc] ", GetColor( @Team! ), @Nick!, white, ": " .. text )

        Jailbreak.SetChatCommand "looc", LOOC
        Jailbreak.SetChatCommand "", LOOC

        CustomEmotion = ( ... ) =>
            Jailbreak.SendChatText( @GetNearPlayers( sqrt( Jailbreak.VoiceChatMinDistance ), false ), @GetPlayerColor!\ToColor!, @Nick!, white, " ", ... )

        Jailbreak.Emotion = CustomEmotion

        Emotion = ( text, ... ) =>
            CustomEmotion( @, lower( text ) )

        Jailbreak.SetChatCommand "e", Emotion
        Jailbreak.SetChatCommand "me", Emotion
        Jailbreak.SetChatCommand "emotion", Emotion

        do

            CoinFlip = ( _, text ) =>
                Emotion( @, "#jb.chat.coin-flip #jb.chat.coin-flip." .. math.random( 0, 1 ) )

            Jailbreak.SetChatCommand "coin", CoinFlip
            Jailbreak.SetChatCommand "flip", CoinFlip

        Jailbreak.SetChatCommand "roll", ( text ) =>
            int1, int2 = string.match( text, "(-?%d+)%s+(-?%d+)" )
            unless int1 and int2
                int1, int2 = 0, 100

            Emotion( @, "#jb.chat.rolled " .. math.random( tonumber( int1 ) or 0, tonumber( int2 ) or 0 ) )

    do

        ConVar = CreateConVar( "jb_ooc", "0", ConVarFlags, "Allows non-game global chat to be used by everyone.", 0, 1 )

        OOC = ( text ) =>
            Jailbreak.SendChatText( false, colors.turquoise, "[#jb.chat.ooc] ", @GetPlayerColor!\ToColor!, @Nick!, white, ": " .. text )
        Jailbreak.OOC = OOC

        Command = ( text ) =>
            if Jailbreak.GameInProgress! and not ( ConVar\GetBool! or @IsAdmin! )
                @SendNotify( "#jb.chat.fail", NOTIFY_ERROR, 5 )
                return

            OOC( @, text )

        Jailbreak.SetChatCommand "ooc", Command
        Jailbreak.SetChatCommand "/", Command

    concommand.Add "jb_force_round", ( _, args ) =>
        if IsValid( ply ) and not ply\IsSuperAdmin!
            return

        index = args[ 1 ]
        if index
            index = tonumber( index ) or 0

        if index
            Jailbreak.SetRoundState( math.Clamp( index, 0, 3 ) )
        else
            Jailbreak.SetRoundState( 0 )
            Jailbreak.SetRoundTime( 0 )

Jailbreak.SetChatCommand "warden", =>
    @ConCommand( "jb_warden" )

GM.OnEntityWaterLevelChanged = ( entity, old, new ) =>
    if new >= 2
        if entity\IsOnFire!
            entity\Extinguish!

        if old < new and new == 3 and entity\IsPlayer! and entity\Alive!
            entity.DrownDamageTime = CurTime! + random( 15, 45 )

do

    damageInfo = DamageInfo!
    damageInfo\SetDamageType( DMG_DROWN )

    GM.PlayerPostThink = ( ply ) =>
        if ply\Alive! and ( ply.NextEyeTargetTime or 0 ) < CurTime!
            ply.NextEyeTargetTime = CurTime! + 0.1

            traceResult = ply\GetEyeTrace!
            if traceResult.Hit
                nextEyePos = LerpVector( 0.5, ply.LastEyePos or Vector!, traceResult.HitPos )
                ply\SetEyeTarget( nextEyePos )
                ply.LastEyePos = nextEyePos

        if ply\IsUnderwater! and ( ply.DrownDamageTime or 0 ) < CurTime!
            ply.DrownDamageTime = CurTime! + 0.5
            damageInfo\SetAttacker( ply )
            damageInfo\SetDamage( max( 5, ply\Health! * 0.1 ) )
            ply\EmitSound( "Player.DrownContinue" )
            ply\TakeDamageInfo( damageInfo )
