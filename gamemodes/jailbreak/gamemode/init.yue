AddCSLuaFile( "shared.lua" )
include( "shared.lua" )
Jailbreak = Jailbreak

ConVarFlags = bit.bor( FCVAR_ARCHIVE, FCVAR_NOTIFY )
CreateConVar = CreateConVar

-- TODO: Write desc
GM.PrepareTime = CreateConVar( "jb_prepare_time", "30", ConVarFlags, "", 10, 2 * 60 * 60 )
GM.RoundTime = CreateConVar( "jb_round_time", "0", ConVarFlags, "", 0, 12 * 60 * 60 )

GM.PlayerRespawnTime = CreateConVar( "jb_respawn_time", "2", ConVarFlags, "", 0, 300 )
GM.DoorsHealth = CreateConVar( "jb_doors_health", "500", ConVarFlags, "", 50, 10000 )
GM.GuardsArmor = CreateConVar( "jb_guards_armor", "0", ConVarFlags, "", 0, 1000 )

GM.FemalePrisonChance = CreateConVar( "jb_female_prison_chance", "10", ConVarFlags, "", 0, 100 )
GM.PrisonerKnifeChance = CreateConVar( "jb_prisoner_knife_chance", "10", ConVarFlags, "", 0, 100 )

RunConsoleCommand( "mp_show_voice_icons", GM.Arcade\GetString! )
cvars.AddChangeCallback( "jb_arcade", ( _, __, value ) ->
    RunConsoleCommand( "mp_show_voice_icons", value )
"Jailbreak" )

Jailbreak.GuardsDiff = 1 / ( CreateConVar( "jb_prisoner_per_guard", "3", ConVarFlags, "", 1, game.MaxPlayers! - 1 )\GetInt! + 1 )
cvars.AddChangeCallback( "jb_prisoner_per_guard", ( _, __, value ) ->
    Jailbreak.GuardsDiff = 1 / ( ( tonumber( value ) or 3 ) + 1 )
"Jailbreak" )

resource.AddWorkshop( "3093227948" )
resource.AddWorkshop( "2950445307" )
resource.AddWorkshop( "2661291057" )
resource.AddWorkshop( "643148462" )

math = math
:Rand, :random, :max, :min = math
:Effect, :IsValidModel, :IsInWorld, :TraceHull, :ScreenShake = util
TEAM_PRISONER = TEAM_PRISONER
table_Empty = table.Empty
ents_Create = ents.Create
TEAM_GUARD = TEAM_GUARD
hook_Run = hook.Run
tonumber = tonumber
IsValid = IsValid

do

    SetGlobal2String = SetGlobal2String
    SetGlobal2Int = SetGlobal2Int

    Jailbreak.SetRoundState = ( state, silent ) ->
        oldState = Jailbreak.GetRoundState!
        SetGlobal2String( "round-state", state )
        unless silent
            hook_Run( "RoundStateChanged", oldState, state )

    Jailbreak.SetWinningTeam = ( teamID ) ->
        SetGlobal2Int( "winning-team", teamID )

    Jailbreak.SetRoundTime = ( int ) ->
        SetGlobal2Int( "next-round-state", CurTime! + int )

do

    ENTITY = FindMetaTable( "Entity" )

    ENTITY.SetCreator = ( entity ) =>
        @SetNW2Entity( "entity-owner", entity )

do

    PLAYER = FindMetaTable( "Player" )

    PLAYER.SetWarden = ( bool ) =>
        @SetNW2Bool( "warden", bool )

    PLAYER.SetElectroCollar = ( bool ) =>
        @SetNW2Bool( "electro-collar", bool )

    PLAYER.AllowSecurityAccess = ( bool ) =>
        @SetNW2Bool( "security-access", bool )

    PLAYER.AllowSecurityRadio = ( bool ) =>
        @SetNW2Bool( "security-radio", bool )

    do

        WeaponHandlers = WeaponHandlers or {}

        PLAYER.Give = ( className, noAmmo ) =>
            weapon = nil

            handler = WeaponHandlers[ className ]
            if handler
                weapon = ents_Create( handler.Alternative or className )
            else
                weapon = ents_Create( className )

            unless weapon and weapon\IsValid!
                return

            weapon\SetAngles( @GetAngles! )
            weapon\SetPos( @GetPos! )

            weapon\Spawn!
            weapon\Activate!

            if weapon\IsWeapon!
                if noAmmo
                    weapon\SetClip1( 0 )
                    weapon\SetClip2( 0 )
                @PickupWeapon( weapon, false )
            return weapon

    PLAYER.SetMutedByWarden = ( bool ) =>
        @SetNW2Bool( "warden-mute", bool )

    PLAYER.RemoveRagdoll = =>
        ragdoll = @GetRagdollEntity!
        if ragdoll\IsValid!
            ragdoll\Remove!

    PLAYER.CreateClientsideRagdoll = PLAYER.CreateClientsideRagdoll or PLAYER.CreateRagdoll
    COLLISION_GROUP_PASSABLE_DOOR = COLLISION_GROUP_PASSABLE_DOOR

    PLAYER.CreateRagdoll = =>
        @RemoveRagdoll!

        modelPath = @GetModel!
        unless IsValidModel( modelPath )
            return

        spawnOrigin = @WorldSpaceCenter!
        unless IsInWorld( spawnOrigin )
            return

        ragdoll = ents_Create( @GetBoneCount! > 1 and "prop_ragdoll" or "prop_physics" )
        ragdoll\SetAngles( @GetAngles! )
        ragdoll\SetModel( modelPath )
        ragdoll\SetPos( spawnOrigin )
        ragdoll\Spawn!

        Jailbreak.PlayerRagdolls[] = ragdoll

        ragdoll.Team = @Team!
        ragdoll.Alive = @Alive!

        ragdoll\SetMaxHealth( @GetMaxHealth! )
        ragdoll\SetHealth( @Health! )

        -- TODO: Custom take damage
        ragdoll.MaxArmor = @GetMaxArmor!
        ragdoll.Armor = @Armor!

        ragdoll.PlayerAngles = @EyeAngles!

        for bodygroup in *@GetBodyGroups!
            ragdoll\SetBodygroup( bodygroup.id, @GetBodygroup( bodygroup.id ) )

        ragdoll\SetFlexScale( @GetFlexScale! )
        for flexID = 0, @GetFlexNum!
            ragdoll\SetFlexWeight( flexID, @GetFlexWeight( flexID ) )

        ragdoll\SetPlayerColor( @GetPlayerColor! )
        ragdoll\SetMaterial( @GetMaterial! )
        ragdoll\SetColor( @GetColor! )
        ragdoll\SetSkin( @GetSkin! )

        for index = 1, #@GetMaterials!
            materialPath = @GetSubMaterial( index )
            if materialPath ~= ""
                ragdoll\SetSubMaterial( index, materialPath )

        ragdoll\SetCollisionGroup( COLLISION_GROUP_PASSABLE_DOOR )
        ragdoll\SetNW2Bool( "is-player-ragdoll", true )
        ragdoll\SetNW2Entity( "ragdoll-owner", @ )
        @SetNW2Entity( "player-ragdoll", ragdoll )

        if @IsBot!
            ragdoll\SetNW2String( "steamid", @SteamID64! )
        ragdoll\SetNW2String( "nickname", @Nick! )
        ragdoll\SetCreator( @ )

        for boneID = 0, @GetBoneCount!
            ragdoll\ManipulateBonePosition( boneID, @GetManipulateBonePosition( boneID ) )
            ragdoll\ManipulateBoneAngles( boneID, @GetManipulateBoneAngles( boneID ) )
            ragdoll\ManipulateBoneJiggle( boneID, @GetManipulateBoneJiggle( boneID ) )
            ragdoll\ManipulateBoneScale( boneID, @GetManipulateBoneScale( boneID ) )

        if ragdoll\IsRagdoll!
            velocity = @LastMoveVelocity
            for physNum = 0, ragdoll\GetPhysicsObjectCount! - 1 do
                phys = ragdoll\GetPhysicsObjectNum( physNum )
                unless IsValid( phys )
                    continue

                boneID = ragdoll\TranslatePhysBoneToBone( physNum )
                if boneID < 0
                    continue

                origin, angles = @GetBonePosition( boneID )
                phys\SetVelocity( velocity )
                phys\SetAngles( angles )
                phys\SetPos( origin )
                phys\Wake!

        else
            phys = ragdoll\GetPhysicsObject!
            if IsValid( phys )
                phys\SetVelocity( @LastMoveVelocity )
                phys\Wake!

        if @IsOnFire!
            ragdoll\Ignite( 16, 64 )
            @Extinguish!

        hook_Run( "PlayerRagdollCreated", @, ragdoll )

        ragdoll.HasSecurityAccess = @HasSecurityAccess!
        ragdoll.HasSecurityRadio = @HasSecurityRadio!
        ragdoll.HasFlashlight = @CanUseFlashlight!

        weapons = {}
        for weapon in *@GetWeapons!
            @DropWeapon( weapon )

            weapon\SetPos( spawnOrigin )
            weapon\SetParent( ragdoll )
            weapon\SetNotSolid( true )
            weapon\SetNoDraw( true )

            weapon.PickupForbidden = true
            weapons[] = weapon
        ragdoll.Weapons = weapons
        ragdoll.Ammo = @GetAmmo!

        return ragdoll

GM.ShowTeam = ( ply ) =>
    ply\ConCommand( "jb_showteam" )

Jailbreak.PlayerRagdolls = Jailbreak.PlayerRagdolls or {}

GM.PlayerInitialSpawn = ( ply, transiton ) =>
    ply.NextRespawnTime = 0
    isBot = ply\IsBot!

    sid64 = isBot and ply\Nick! or ply\SteamID64!
    for ragdoll in *Jailbreak.PlayerRagdolls
        if sid64 == ( isBot and ragdoll\GetNW2String( "nickname" ) or ragdoll\GetNW2String( "steamid" ) )
            ply\SetNW2Entity( "player-ragdoll", ragdoll )
            break

    if isBot
        ply\SetTeam( TEAM_PRISONER )
    else
        ply\SetTeam( TEAM_SPECTATOR )
        ply.AvailableSpeakers = {}

    ragdoll = ply\GetRagdollEntity!
    if ragdoll\IsValid!
        ply\SetTeam( ragdoll.Team )

        unless ragdoll.Alive and ragdoll\Health! > 1
            ply\KillSilent!
            ply\Spectate( OBS_MODE_ROAMING )
            return

        ply\SetEyeAngles( Angle( 0, ragdoll.PlayerAngles[ 2 ], 0 ) )
        ply\SetPos( ragdoll\WorldSpaceCenter! )
        ply\SetModel( ragdoll\GetModel! )

        ply\SetHealth( ply\GetMaxHealth! * ( ragdoll\Health! / ragdoll\GetMaxHealth! ) )
        ply\SetArmor( ply\GetMaxArmor! * ( ragdoll.Armor / ragdoll.MaxArmor ) )

        ply\SetMaterial( ragdoll\GetMaterial! )
        ply\SetColor( ragdoll\GetColor! )
        ply\SetSkin( ragdoll\GetSkin! )

        for bodygroup in *ply\GetBodyGroups!
            ply\SetBodygroup( bodygroup.id, ragdoll\GetBodygroup( bodygroup.id ) )

        ply\SetFlexScale( ragdoll\GetFlexScale! )
        for flexID = 0, ply\GetFlexNum!
            ply\SetFlexWeight( flexID, ragdoll\GetFlexWeight( flexID ) )

        for index = 1, #ply\GetMaterials!
            materialPath = ragdoll\GetSubMaterial( index )
            if materialPath ~= ""
                ply\SetSubMaterial( index, materialPath )

        if ragdoll\IsOnFire!
            ply\Ignite( 16, 64 )
            ragdoll\Extinguish!

        for boneID = 0, ply\GetBoneCount!
            ply\ManipulateBonePosition( boneID, ragdoll\GetManipulateBonePosition( boneID ) )
            ply\ManipulateBoneAngles( boneID, ragdoll\GetManipulateBoneAngles( boneID ) )
            ply\ManipulateBoneJiggle( boneID, ragdoll\GetManipulateBoneJiggle( boneID ) )
            ply\ManipulateBoneScale( boneID, ragdoll\GetManipulateBoneScale( boneID ) )

        if ragdoll\IsRagdoll!
            velocity = Vector!

            count = ragdoll\GetPhysicsObjectCount!
            for physNum = 0, count - 1
                phys = ragdoll\GetPhysicsObjectNum( physNum )
                if IsValid( phys )
                    velocity += phys\GetVelocity!

            velocity /= count
            ply\SetVelocity( velocity )
        else
            phys = ragdoll\GetPhysicsObject!
            if IsValid( phys )
                ply\SetVelocity( phys\GetVelocity! )

        hook_Run( "PlayerRagdollUse", ragdoll, ply )
        ragdoll\Remove!

GM.PlayerSpawn = ( ply, transiton ) =>
    ply\DisableWorldClicking( true )
    ply\SetCanZoom( false )
    ply\RemoveRagdoll!
    ply\RemoveAllAmmo!
    ply\StripWeapons!
    ply\UnSpectate!

    ply\SetSlowWalkSpeed( 100 )
    ply\SetWalkSpeed( 185 )
    ply\SetRunSpeed( 365 )

    ply\SetMaxHealth( 100 )
    ply\SetMaxArmor( 100 )
    ply\SetHealth( 100 )

    teamID = ply\Team!
    if teamID == TEAM_GUARD
        ply\SetArmor( @GuardsArmor\GetInt! )
    else
        ply\SetArmor( 0 )

    ply\SetMaxArmor( max( 100, ply\Armor! ) )

    if teamID == TEAM_PRISONER
        ply\SetNoCollideWithTeammates( false )
        ply\SetElectroCollar( true )
        ply\SetAvoidPlayers( true )
    else
        ply\SetNoCollideWithTeammates( true )
        ply\SetElectroCollar( false )
        ply\SetAvoidPlayers( false )

    if teamID == TEAM_GUARD
        ply\AllowSecurityAccess( true )
        ply\AllowSecurityRadio( true )
        ply\AllowFlashlight( true )
    else
        ply\AllowSecurityAccess( false )
        ply\AllowSecurityRadio( false )
        ply\AllowFlashlight( false )

    if teamID > 1000
        ply\KillSilent!
        ply\Spectate( OBS_MODE_ROAMING )
        return

    unless transiton
        hook_Run( "PlayerLoadout", ply, teamID )
    hook_Run( "PlayerSetModel", ply, teamID )

    if ply\IsBot!
        ply\SetPlayerColor( Vector( Rand( 0, 1 ), Rand( 0, 1 ), Rand( 0, 1 ) ) )
        ply\SetWeaponColor( Vector( Rand( 0, 1 ), Rand( 0, 1 ), Rand( 0, 1 ) ) )
    else
        ply\SetPlayerColor( Vector( ply\GetInfo( "cl_playercolor" ) ) )
        ply\SetSkin( ply\GetInfoNum( "cl_playerskin", 0 ) )

        weaponColor = Vector( ply\GetInfo( "cl_weaponcolor" ) )
        if weaponColor\Length! < 0.001
            weaponColor = Vector( 0.001, 0.001, 0.001 )
        ply\SetWeaponColor( weaponColor )

        groups = string.Explode( " ", ply\GetInfo( "cl_playerbodygroups" ) or "" )
        for i = 0, ply\GetNumBodyGroups! - 1 do
            ply\SetBodygroup( i, tonumber( groups[ i + 1 ] ) or 0 )

    hook_Run( "TeamPlayerSpawn", ply, teamID )
    ply\SetupHands!

GM.OnEntityCreated = ( weapon ) =>
    if weapon\GetClass! == "game_player_equip"
        weapon\Remove!
        return

    unless weapon\IsWeapon!
        return

    timer.Simple 0.025, ->
        unless weapon\IsValid!
            return

        if IsValid( weapon\GetOwner! )
            return

        if weapon\GetPos!\Length! <= 3
            weapon\Remove!
            return

        weapon\SetCollisionGroup( COLLISION_GROUP_WEAPON )

        phys = weapon\GetPhysicsObject!
        unless IsValid( phys ) and phys\IsMotionEnabled!
            return

        counter = 0
        for entity in *ents.FindInSphere( weapon\GetPos!, 32 )
            if entity\IsWeapon! and not IsValid( entity\GetOwner! )
                counter = counter + 1
                if counter >= 5
                    phys\EnableMotion( false )
                    return

COLLISION_GROUP_DEBRIS = COLLISION_GROUP_DEBRIS

GM.PlayerDroppedWeapon = ( ply, weapon ) =>
    timerName = "JB_WeaponDrop #" .. weapon\EntIndex!
    timer.Create( timerName, 3, 1, ->
        timer.Remove( timerName )
        unless weapon\IsValid!
            return

        phys = weapon\GetPhysicsObject!
        unless IsValid( phys )
            return

        start = weapon\WorldSpaceCenter!
        mins, maxs = weapon\GetCollisionBounds!

        tr = TraceHull( {
            start: start
            endpos: start + Vector( 0, 0, mins[ 3 ] - 2 )
            mask: MASK_SOLID_BRUSHONLY
            mins: mins
            maxs: maxs
        } )

        if tr.Hit
            weapon\SetCollisionGroup( COLLISION_GROUP_DEBRIS )
            phys\EnableMotion( false )
            return

        @PlayerDroppedWeapon( ply, weapon )
    )

GM.PlayerLoadout = ( ply, teamID ) =>
    if teamID == TEAM_GUARD
        ply\GiveAmmo( 7, "357", true )
        ply\GiveAmmo( 60, "ar2", true )
        ply\GiveAmmo( 90, "smg1", true )
        ply\GiveAmmo( 40, "Pistol", true )
        ply\GiveAmmo( 20, "Buckshot", true )

    if @Arcade\GetBool!
        ply\Give( "weapon_knife" )
        return

    if teamID == TEAM_PRISONER and not ply\HasWeapon( "weapon_knife" ) and random( 1, 100 ) <= @PrisonerKnifeChance\GetInt!
        ply\Give( "weapon_knife" )

    ply\Give( "jb_hands" )
    ply\SelectWeapon( "jb_hands" )

GM.PlayerSetModel = ( ply, teamID ) =>
    models = @PlayerModels[ teamID ]
    if teamID == TEAM_PRISONER
        models = models[ @FemalePrison and 1 or 2 ]

    requested = player_manager.TranslatePlayerModel( ply\GetInfo( "cl_playermodel" ) )
    if requested and #requested > 0
        requestedName = string.match( requested, "([%w%_%-]+)%.mdl$" )
        for modelPath in *models
            if modelPath == requested or string.match( modelPath, "([%w%_%-]+)%.mdl$" ) == requestedName
                ply\SetModel( modelPath )
                return

    ply\SetModel( table.Random( models ) )

GM.PlayerSetHandsModel = ( ply, hands ) =>
    info = player_manager.TranslatePlayerHands( player_manager.TranslateToPlayerModelName( ply\GetModel! ) )
    unless info
        return

    hands\SetModel( info.model )
    hands\SetSkin( info.matchBodySkin and ply\GetSkin! or info.skin )
    hands\SetBodyGroups( info.body )

GM.IsSpawnpointSuitable = ( ply, entity, makeSuitable ) =>
    start = entity\GetPos!
    mins, maxs = ply\GetHull!

    traceResult = TraceHull( {
        start: start
        endpos: start
        mask: MASK_PLAYERSOLID
        filter: entity
        mins: mins
        maxs: maxs
    } )

    if traceResult.Hit
        if makeSuitable
            traceEntity = traceResult.Entity
            if traceEntity\IsValid! and traceEntity\IsPlayer! and traceEntity\Alive!
                traceEntity\Kill!
                return true
        return false
    return true

GM.PlayerSelectTeamSpawn = ( teamID, ply ) =>
	spawnPoints = team.GetSpawnPoints( teamID )
    unless spawnPoints and not table.IsEmpty( spawnPoints )
        return

    if teamID == TEAM_GUARD
        return table.Random( spawnPoints )

    if teamID == TEAM_PRISONER
        for i = 0, 16
            spawnPoint = table.Random( spawnPoints )
            if hook_Run( "IsSpawnpointSuitable", ply, spawnPoint, i > 10 )
                return spawnPoint

GM.DoPlayerDeath = ( ply, attacker, damageInfo ) =>
    if ply\Team! > 1000
        return

    ply\AddDeaths( 1 )

    ragdoll = ply\CreateRagdoll!
    unless IsValid( ragdoll )
        return

    damageOrigin = damageInfo\GetDamagePosition!
    if damageOrigin\Length! < 1
        damageOrigin = ragdoll\WorldSpaceCenter!

    if ragdoll\IsRagdoll!
        velocity = damageInfo\GetDamageForce!
        for physNum = 0, ragdoll\GetPhysicsObjectCount! - 1 do
            phys = ragdoll\GetPhysicsObjectNum( physNum )
            if IsValid( phys )
                phys\ApplyForceOffset( velocity / phys\GetMass!, damageOrigin )

    else
        phys = ragdoll\GetPhysicsObject!
        if IsValid( phys )
            phys\ApplyForceOffset( damageInfo\GetDamageForce! / phys\GetMass!, damageOrigin )

GM.PlayerSilentDeath = ( ply ) =>
    teamID = ply\Team!
    if teamID <= 1000
        hook_Run( "TeamPlayerDeath", ply, teamID )
    ply\Spectate( OBS_MODE_ROAMING )

GM.PlayerDeath = ( ply, inflictor, attacker ) =>
    teamID = ply\Team!
    if teamID <= 1000
        hook_Run( "TeamPlayerDeath", ply, teamID )

    if attacker\IsPlayer! and attacker\Alive! and attacker\Team! <= 1000
        if attacker == ply
            ply\Spectate( OBS_MODE_ROAMING )
        else
            ply\Spectate( OBS_MODE_CHASE )
            ply\SpectateEntity( attacker )

    -- TODO: Write here death notifies

GM.PlayerDeathThink = ( ply ) =>
    if ply\Team! > 1000
        return

    if Jailbreak.GameInProgress!
        return

    if ply.NextRespawnTime > CurTime!
        return

    ply\Spawn!

GM.PreCleanupMap = =>
    table_Empty( Jailbreak.PlayerRagdolls )

GM.EntityRemoved = ( entity, fullUpdate ) =>
    if fullUpdate
        return

    if entity\IsPlayerRagdoll!
        table.RemoveByValue( Jailbreak.PlayerRagdolls, entity )

GM.PlayerDisconnected = ( ply ) =>
    teamID = ply\Team!
    if teamID <= 1000
        hook_Run( "TeamPlayerDisconnected", ply, teamID )

DMG_NEVERGIB = DMG_NEVERGIB

do

    GM.CloseRangeDamageTypes = { DMG_SLASH, DMG_FALL, DMG_CLUB, DMG_CRUSH }

    GM.PlayerTakeDamage = ( ply, damageInfo, teamID ) =>
        damageType = damageInfo\GetDamageType!
        if ply\HasElectroCollar! and bit.band( damageType, DMG_SHOCK ) == DMG_SHOCK
            ply\SetElectroCollar( false )

        unless Jailbreak.IsElectroCollarsActive!
            return

        attacker = damageInfo\GetAttacker!
        unless attacker\IsValid! and attacker\IsPlayer! and attacker\HasElectroCollar!
            return

        for int in *@CloseRangeDamageTypes
            if bit.band( damageType, int ) == int
                fx = EffectData!
                fx\SetScale( 0.5 )
                origin = nil

                headBone = attacker\LookupBone( "ValveBiped.Bip01_Head1" )
                if headBone >= 0
                    matrix = attacker\GetBoneMatrix( headBone )
                    if matrix
                        origin = matrix\GetTranslation!

                fx\SetOrigin( origin or attacker\EyePos! )
                fx\SetMagnitude( random( 3, 5 ) )
                fx\SetRadius( random( 1, 5 ) )
                Effect( "ElectricSpark", fx )

                damageInfo\SetDamageType( DMG_SONIC )
                damageInfo\ScaleDamage( 0.5 )
                attacker\TakeDamageInfo( damageInfo )

                damageInfo\SetDamageType( damageType )
                damageInfo\ScaleDamage( 0.5 )
                break

GM.EntityTakeDamage = ( entity, damageInfo ) =>
    if entity\IsPlayerRagdoll!
        return true

    if entity\IsPlayer!
        if entity\Alive!
            teamID = entity\Team!
            if hook_Run( "CanPlayerTakeDamage", entity, damageInfo, teamID ) ~= false
                return hook_Run( "PlayerTakeDamage", entity, damageInfo, teamID )
        return true

    if bit.band( damageInfo\GetDamageType!, DMG_NEVERGIB ) == DMG_NEVERGIB
        return

    switch entity\GetClass!
        when "prop_door_rotating"
            maxHealth = entity\GetMaxHealth!
            if maxHealth <= 1
                maxHealth = @DoorsHealth\GetInt!
                if maxHealth <= 0
                    return true

                entity\SetHealth( maxHealth )
                entity\SetMaxHealth( maxHealth )

            health = entity\Health!
            if health < 1
                return true

            health = max( 0, health - damageInfo\GetDamage! )
            entity\SetHealth( health )

            if health > 1
                return true

            model = entity\GetModel!
            unless model and #model ~= 0 and IsValidModel( model )
                return true

            center = entity\OBBCenter!
            center[ 1 ] = 0
            center[ 2 ] = 0

            origin = entity\LocalToWorld( center )
            unless IsInWorld( origin )
                return true

            prop = ents_Create( "prop_physics" )
            prop\SetCollisionGroup( COLLISION_GROUP_WEAPON )
            prop\SetAngles( entity\GetAngles! )
            prop\SetSkin( entity\GetSkin! )
            prop\SetModel( model )
            prop\SetPos( origin )
            prop\Spawn!

            name = entity\GetName!
            if name ~= ""
                for portal in *ents.FindByClass( "func_areaportal" )
                    if portal\GetInternalVariable( "target" ) ~= name
                        continue

                    portal\SetSaveValue( "target", "" )
                    portal\Fire( "open" )

            prop\EmitSound( "physics/wood/wood_crate_break" .. random( 1, 5 ) .. ".wav", 70, random( 80, 120 ), 1, CHAN_STATIC, 0, 1 )
            entity\Remove!

            phys = prop\GetPhysicsObject!
            if IsValid( phys )
                phys\ApplyForceOffset( damageInfo\GetDamageForce!, damageInfo\GetDamagePosition! )

            origin = damageInfo\GetDamagePosition!
            fx = EffectData!
            fx\SetOrigin( origin )
            fx\SetMagnitude( 5 )
            fx\SetRadius( 5 )
            fx\SetScale( 2 )
            Effect( "Sparks", fx )
            ScreenShake( origin, 5, 10, 0.5, 150 )
            return true
        when "func_button"
            if bit.band( damageInfo\GetDamageType!, DMG_BLAST ) == DMG_BLAST
                return true

            attacker = damageInfo\GetAttacker!
            if IsValid( attacker ) and attacker\IsPlayer!
                entity\Use( attacker, attacker )
            return true

do

    :ceil = math

    GM.GetFallDamage = ( ply, speed ) =>
        return max( 0, ceil( 0.2418 * speed - 141.75 ) )

GM.PlayerShouldTaunt = ( ply ) =>
    return ply\Team! <= 1000 and ply\Alive!

GM.AllowPlayerPickup = ( ply, entity ) =>
    if ply\Team! > 1000 or not ply\Alive!
        return false

    if @Arcade\GetBool!
        return true

    weapon = ply\GetActiveWeapon!
    return IsValid( weapon ) and weapon\GetClass! == "jb_hands"

GM.PlayerCanPickupItem = ( ply, entity ) =>
    return ply\Team! <= 1000 and ply\Alive!

GM.PlayerCanPickupWeapon = ( ply, weapon ) =>
    return @Arcade\GetBool! and not ply\HasWeapon( weapon\GetClass! ) and ply\Alive!

GM.PlayerNoClip = ( ply, desiredState ) =>
    return not desiredState or ply\Team! <= 1000 and ply\IsSuperAdmin! and ply\Alive!

GM.CanPlayerSuicide = ( ply ) =>
    return ply\Team! <= 1000 and not Jailbreak.IsRoundPreparing! and ply\Alive!

GM.PlayerSwitchFlashlight = ( ply ) =>
    return ( @Arcade\GetBool! or ply\CanUseFlashlight! ) and ply\Alive!

GM.PlayerDeathSound = ( ply ) =>
    return not Jailbreak.IsRoundRunning! or @Arcade\GetBool! or ply\IsPrisoner!

GM.PlayerRagdollUse = ( ragdoll, ply ) =>
    velocity = Vector!

    direction = ply\EyePos! - ragdoll\WorldSpaceCenter!
    direction\Normalize!

    if ragdoll.HasFlashlight and not ply\CanUseFlashlight!
        velocity += direction * 150
        ply\AllowFlashlight( true )
        ragdoll.HasFlashlight = nil

    if ragdoll.HasSecurityAccess and not ply\HasSecurityAccess!
        velocity += direction * 50
        ply\AllowSecurityAccess( true )
        ragdoll.HasSecurityAccess = nil

    if ragdoll.HasSecurityRadio and not ply\HasSecurityRadio!
        velocity += direction * 50
        ply\AllowSecurityRadio( true )
        ragdoll.HasSecurityRadio = nil

    weapons = ragdoll.Weapons
    if istable( weapons )
        for weapon in *weapons
            unless weapon\IsValid! and not IsValid( weapon\GetOwner! )
                continue

            weapon\SetNotSolid( false )
            weapon\SetNoDraw( false )
            weapon\SetParent!

            weapon.PickupForbidden = nil
            ply\PickupWeapon( weapon )
            velocity += direction * 200
    ragdoll.Weapons = nil

    ammo = ragdoll.Ammo
    if istable( ammo )
        for ammoType, ammoCount in pairs( ammo )
            ply\GiveAmmo( ammoCount, ammoType )
            velocity += direction * 100
    ragdoll.Ammo = nil

    if velocity\Length! < 100
        return

    if ragdoll\IsRagdoll!
        physParts = {}
        for physNum = 1, ragdoll\GetPhysicsObjectCount! - 1 do
            phys = ragdoll\GetPhysicsObjectNum( physNum )
            if IsValid( phys )
                physParts[] = phys

        table.Shuffle( physParts )

        for index = 1, min( #physParts, 4 )
            physParts[ index ]\ApplyForceCenter( velocity )

    else
        phys = ragdoll\GetPhysicsObject!
        if IsValid( phys )
            phys\ApplyForceCenter( velocity )

GM.PlayerSpray = ( ply ) =>
    return ply\Alive! and ply\IsPrisoner!

GM.PlayerUse = ( ply, entity ) =>
    unless ply\Alive! and ply\Team! <= 1000
        return

    unless @Arcade\GetBool!
        weapon = ply\GetActiveWeapon!
        if IsValid( weapon ) and weapon\GetHoldType! == "fist" and entity\IsPlayer!
            velocity = ply\GetVelocity!\GetNormalized! * 16
            entity\SetVelocity( velocity )
            ply\SetVelocity( -velocity )
            return false

    curTime, lastUse = CurTime!, ply.LastUse or 0
    ply.LastUse = curTime

    if ( curTime - lastUse ) <= 0.025
        return

    if entity\IsPlayerRagdoll!
        hook_Run( "PlayerRagdollUse", entity, ply )
        return false

    if entity\IsWeapon!
        if entity.PickupForbidden or entity.IsTemporaryWeapon or entity\IsPlayerHolding!
            return false

        if not ply\HasWeapon( entity\GetClass! ) and not @Arcade\GetBool!
            ply\PickupWeapon( entity, false )
            return false

        pickedAmmo = false

        clip1, clip1Type = entity\Clip1!, entity\GetPrimaryAmmoType!
        if clip1 > 0 and clip1Type >= 0 and ply\GetAmmoCount( clip1Type ) < ( game.GetAmmoMax( clip1Type ) / 2 )
            ply\GiveAmmo( clip1, clip1Type, false )
            entity\SetClip1( 0 )
            pickedAmmo = true

        clip2, clip2Type = entity\Clip2!, entity\GetSecondaryAmmoType!
        if clip2 > 0 and clip2Type >= 0 and ply\GetAmmoCount( clip2Type ) < ( game.GetAmmoMax( clip2Type ) / 2 )
            ply\GiveAmmo( clip2, clip2Type, false )
            entity\SetClip2( 0 )
            pickedAmmo = true

        if not pickedAmmo and not @Arcade\GetBool!
            phys = entity\GetPhysicsObject!
            if IsValid( phys )
                phys\EnableMotion( true )
                phys\Wake!
            ply\PickupObject( entity )

            hook.Add "Think", entity, ->
                if entity\GetCollisionGroup! ~= COLLISION_GROUP_DEBRIS
                    entity\SetCollisionGroup( COLLISION_GROUP_DEBRIS )
                unless entity\IsPlayerHolding!
                    hook.Remove "Think", entity

        return false

    return true

do

    DistToSqr = FindMetaTable( "Vector" ).DistToSqr
    EyePos = FindMetaTable( "Entity" ).EyePos
    player_GetHumans = player.GetHumans
    RecipientFilter = RecipientFilter
    :Clamp, :Round = math
    net = net

    util.AddNetworkString( "JB::Voice Chat" )

    MinDistance = CreateConVar( "jb_voice_chat_distance_min", "64", ConVarFlags, "", 32, 16384 )\GetInt! ^ 2
    MaxDistance = CreateConVar( "jb_voice_chat_distance_max", "512", ConVarFlags, "", 128, 16384 )\GetInt! ^ 2

    cvars.AddChangeCallback( "jb_voice_chat_distance_min", ( _, __, value ) ->
        MinDistance = ( tonumber( value ) or 100 ) ^ 2
    "Jailbreak" )

    cvars.AddChangeCallback( "jb_voice_chat_distance_max", ( _, __, value ) ->
        MaxDistance = ( tonumber( value ) or 100 ) ^ 2
    "Jailbreak" )

    OOC = GetConVar( "sv_alltalk" )\GetInt! > 2
    cvars.AddChangeCallback( "sv_alltalk", ( _, __, value ) ->
        OOC = ( tonumber( value ) or 2 ) > 2
    "Jailbreak" )

    CanHear = ( listener, speaker ) ->
        if not Jailbreak.GameInProgress! or OOC
            return true, false

        listenerAlive, speakerAlive = listener\Alive!, speaker\Alive!
        if speakerAlive
            if speaker\IsMutedByWarden!
                return false, false
        else
            return not listenerAlive, false

    timer.Create "JB:Voice Chat Think", 1, 0, ->
        players = player_GetHumans!
        for listener in *players
            speakers = listener.AvailableSpeakers
            table_Empty( speakers )

            origin = EyePos( listener )
            rf = RecipientFilter!
            rf\AddPAS( origin )

            listenerIndex = listener\EntIndex!
            for speaker in *rf\GetPlayers!
                if speaker\IsBot! or speaker\EntIndex! == listenerIndex or not CanHear( listener, speaker )
                    continue

                volume = Round( 1 - Clamp( max( 0, DistToSqr( origin, EyePos( speaker ) ) - MinDistance ) / MaxDistance, 0, 1 ), 2 )
                if volume > 0
                    speakers[ speaker ] = volume

            if listener\HasSecurityRadio!
                for speaker in *players
                    if speaker\HasSecurityRadio! and speaker\GetInfo( "cl_security_radio" )
                        speakers[ speaker ] = 1

            net.Start( "JB::Voice Chat" )
            net.WriteTable( speakers )
            net.Send( listener )

            listener.AvailableSpeakers = speakers

    GM.PlayerCanSeePlayersChat = ( str, isTeam, listener, speaker ) =>
        if listener\IsBot!
            return false

        unless IsValid( speaker )
            return true

        if isTeam and listener\Team! ~= speaker\Team!
            return false

        canHear = CanHear( listener, speaker )
        if canHear ~= nil
            return canHear

        return listener.AvailableSpeakers[ speaker ] ~= nil

    GM.PlayerCanHearPlayersVoice = ( listener, speaker ) =>
        if listener\IsBot!
            return false, false

        canHear, is3D = CanHear( listener, speaker )
        if canHear ~= nil
            return canHear, is3D

        if listener.AvailableSpeakers[ speaker ] ~= nil
            return true, true

        return false, false

GM.GetTeamAliveCount = ( teamID ) =>
    alive = 0
    for ply in *team.GetPlayers( teamID )
        if ply\Alive!
            alive += 1
    return alive

GM.PlayerRequestTeam = ( ply, teamID ) =>
    unless team.Joinable( teamID )
        return

    oldTeamID = ply\Team!
    if oldTeamID == teamID
        return

    if teamID == TEAM_GUARD
        guardCount = @GetTeamAliveCount( TEAM_GUARD )
        unless guardCount == 0 or ( guardCount / @GetTeamAliveCount( TEAM_PRISONER ) ) < Jailbreak.GuardsDiff
            -- TODO: here chat message
            return

    if ply\Alive!
        if oldTeamID <= 1000
            ply\Kill!
        else
            ply\KillSilent!

    ply\SetTeam( teamID )

concommand.Add( "drop", ( ply ) ->
    dropWeapon = ply\GetActiveWeapon!
    unless IsValid( dropWeapon )
        return

    model = dropWeapon\GetWeaponWorldModel!
    unless model and IsValidModel( model )
        return

    ply\DropWeapon( dropWeapon )

    maxWeight, nextWeapon = nil, nil
    for weapon in *ply\GetWeapons!
        weight = weapon\GetWeight!

        if not maxWeight or maxWeight <= weight
            nextWeapon = weapon
            maxWeight = weight

    unless IsValid( nextWeapon )
        return

    ply\SelectWeapon( nextWeapon\GetClass! )
)

GM.InitPostEntity = =>
    RunConsoleCommand( "sv_defaultdeployspeed", "1" )
    Jailbreak.SetRoundState( "waiting" )

GM.Think = =>
    if Jailbreak.GetRoundTime! <= CurTime!
        switch Jailbreak.GetRoundState!
            when "preparing"
                Jailbreak.SetRoundState( "running" )
            when "running"
                if @RoundTime\GetInt! == 0
                    return

                team.AddScore( TEAM_GUARD, 1 )
                Jailbreak.SetWinningTeam( TEAM_GUARD )

                Jailbreak.SetRoundState( "ended", true )
                Jailbreak.SetRoundTime( @PrepareTime\GetInt! )
            when "ended"
                Jailbreak.SetRoundState( "waiting" )

GM.GetBotFromTeam = ( teamID ) =>
    for ply in *team.GetPlayers( teamID )
        if ply\IsBot!
            return ply

GM.RoundStateChanged = ( old, new ) =>
    switch ( new )
        when "waiting"
            for ply in *player.GetAll!
                if ply\IsBot!
                    ply\SetTeam( TEAM_PRISONER )
                elseif ply\Team! <= 1000
                    ply\KillSilent!
    		timer.Simple( 0, game.CleanUpMap )

        when "preparing"
            @FemalePrison = random( 1, 100 ) <= @FemalePrisonChance\GetInt!
            for ply in *player.GetAll!
                if ply\IsBot!
                    ply\SetTeam( TEAM_PRISONER )

                if ply\Team! <= 1000
                    ply\Spawn!
    		timer.Simple( 0, game.CleanUpMap )

        when "running"
            guardCount, prisonerCount = team.NumPlayers( TEAM_GUARD ), team.NumPlayers( TEAM_PRISONER )
            totalCount = guardCount + prisonerCount

            while ( guardCount / prisonerCount ) > Jailbreak.GuardsDiff and totalCount > ( ( 1 / Jailbreak.GuardsDiff ) + guardCount )
                for i = 1, guardCount
                    guard = @GetBotFromTeam( TEAM_GUARD ) or table.Random( team.GetPlayers( TEAM_GUARD ) )
                    if guard\IsValid!
                        guard\SetTeam( TEAM_PRISONER )
                        guard\Spawn!
                        break
                guardCount, prisonerCount = team.NumPlayers( TEAM_GUARD ), team.NumPlayers( TEAM_PRISONER )
                totalCount = guardCount + prisonerCount

            if guardCount == 0 or prisonerCount == 0
                Jailbreak.SetRoundState( "waiting" )
                return

            for ply in *player.GetAll!
                if ply\IsBot!
                    guardCount = team.NumPlayers( TEAM_GUARD )
                    if guardCount == 0 or ( guardCount / team.NumPlayers( TEAM_PRISONER ) ) < Jailbreak.GuardsDiff
                        ply\SetTeam( TEAM_GUARD )
                    else
                        ply\SetTeam( TEAM_PRISONER )
                    ply\Spawn!
                elseif ply\Team! <= 1000 and not ply\Alive!
                    ply\Spawn!

            roundTime = @RoundTime\GetInt!
            if roundTime > 0
                Jailbreak.SetRoundTime( roundTime )

        when "ended"
            guardCount, prisonerCount = @GetTeamAliveCount( TEAM_GUARD ), @GetTeamAliveCount( TEAM_PRISONER )
            if guardCount > prisonerCount
                team.AddScore( TEAM_GUARD, 1 )
                Jailbreak.SetWinningTeam( TEAM_GUARD )
            elseif guardCount < prisonerCount
                team.AddScore( TEAM_PRISONER, 1 )
                Jailbreak.SetWinningTeam( TEAM_PRISONER )
            else
                Jailbreak.SetWinningTeam( 0 )
            Jailbreak.SetRoundTime( @PrepareTime\GetInt! )

GM.TeamPlayerDeath = ( ply, teamID ) =>
    ply.NextRespawnTime = CurTime! + @PlayerRespawnTime\GetFloat!

    ply\AllowSecurityAccess( false )
    ply\AllowSecurityRadio( false )
    ply\SetElectroCollar( false )
    ply\AllowFlashlight( false )

    timer.Create "Jailbreak::TeamPlayerDeath", 0.5, 1, ->
        timer.Remove "Jailbreak::TeamPlayerDeath"

        if Jailbreak.IsRoundRunning! and ( @GetTeamAliveCount( TEAM_GUARD ) == 0 or @GetTeamAliveCount( TEAM_PRISONER ) == 0 )
            Jailbreak.SetRoundState( "ended" )

GM.TeamPlayerDisconnected = ( ply, teamID ) =>
    timer.Create "Jailbreak::TeamPlayerDisconnected", 0.5, 1, ->
        timer.Remove "Jailbreak::TeamPlayerDisconnected"

        if Jailbreak.IsRoundRunning! and ( @GetTeamAliveCount( TEAM_GUARD ) == 0 or @GetTeamAliveCount( TEAM_PRISONER ) == 0 )
            Jailbreak.SetRoundState( "ended" )

    ply\CreateRagdoll!

GM.TeamPlayerSpawn = ( ply ) =>
    if Jailbreak.IsWaitingPlayers! and @GetTeamAliveCount( TEAM_GUARD ) > 0 and @GetTeamAliveCount( TEAM_PRISONER ) > 0
        Jailbreak.SetRoundState( "preparing" )
        Jailbreak.SetRoundTime( @PrepareTime\GetInt! )

concommand.Add( "changeteam", ( ply, _, args ) ->
    hook_Run( "PlayerRequestTeam", ply, tonumber( args[ 1 ] ) )
)

GM.SetElectroCollars = ( enable ) =>
    SetGlobal2Bool( "electro-collars", enable )
