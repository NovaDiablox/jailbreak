AddCSLuaFile( "shared.lua" )
include( "shared.lua" )

-- TODO: Write desc
GM.DoorsHealth = CreateConVar( "jb_doors_health", "250", FCVAR_ARCHIVE, "", 50, 10000 )
GM.Preparing = CreateConVar( "jb_preparing", "30", FCVAR_ARCHIVE, "", 5, 900 )

resource.AddSingleFile( "resource/localization/en/jailbreak.properties" )
resource.AddWorkshop( "2950445307" )
resource.AddWorkshop( "643148462" )

TEAM_PRISONER = TEAM_PRISONER
TEAM_GUARD = TEAM_GUARD
hook_Run = hook.Run
tonumber = tonumber

-- TODO: Write desc
GM.GuardsDiff = 1 / ( CreateConVar( "jb_prisoner_per_guard", "3", FCVAR_ARCHIVE, "", 1, game.MaxPlayers() - 1 )\GetInt! + 1 )
cvars.AddChangeCallback( "jb_prisoner_per_guard", ( _, __, value ) ->
    (GM or GAMEMODE).GuardsDiff = 1 / ( ( tonumber( value ) or 3 ) + 1 )
"Jailbreak" )

if CreateConVar( "jb_realistic", "0", FCVAR_ARCHIVE, "", 0, 1 )\GetBool!
    RunConsoleCommand( "sv_defaultdeployspeed", "1" )
    RunConsoleCommand( "mp_show_voice_icons", "0" )

cvars.AddChangeCallback( "jb_realistic", ( _, __, value ) ->
    if value == "1"
        RunConsoleCommand( "sv_defaultdeployspeed", "1" )
        RunConsoleCommand( "mp_show_voice_icons", "0" )
    else
        RunConsoleCommand( "sv_defaultdeployspeed", "4" )
        RunConsoleCommand( "mp_show_voice_icons", "1" )
"Jailbreak" )

GM.ShowTeam = ( ply ) =>
    ply\ConCommand( "jb_showteam" )

GM.PlayerInitialSpawn = ( ply, transiton ) =>
    if ply\IsBot! and not @GameInProgress!
        ply\SetTeam( TEAM_PRISONER )
        return

    ply\SetTeam( TEAM_SPECTATOR )

GM.PlayerSpawn = ( ply, transiton ) =>
    ply\AllowFlashlight( false )
    ply\SetCanZoom( false )
    ply\RemoveAllAmmo!
    ply\StripWeapons!
    ply\UnSpectate!

    ply\SetSlowWalkSpeed( 100 )
    ply\SetWalkSpeed( 185 )
    ply\SetRunSpeed( 365 )

    ply\SetMaxHealth( 100 )
    ply\SetMaxArmor( 100 )
    ply\SetHealth( 100 )

    teamID = ply\Team!
    if teamID == TEAM_GUARD
        ply\SetArmor( 50 )
    else
        ply\SetArmor( 0 )

    if teamID == TEAM_PRISONER
        ply\SetNoCollideWithTeammates( false )
        ply\SetAvoidPlayers( true )
    else
        ply\SetNoCollideWithTeammates( true )
        ply\SetAvoidPlayers( false )

    unless @PlayableTeams[ teamID ]
        ply\Spectate( OBS_MODE_ROAMING )
        ply\SetNoDraw( true )
        return

    ply\SetNoDraw( false )

    unless transiton
        ply.Loadout = true
        hook_Run( "PlayerLoadout", ply, teamID )
        ply.Loadout = nil
    hook_Run( "PlayerSetModel", ply, teamID )

    if ply\IsBot!
        ply\SetPlayerColor( Vector( math.Rand( 0, 1 ), math.Rand( 0, 1 ), math.Rand( 0, 1 ) ) )
        ply\SetWeaponColor( Vector( math.Rand( 0, 1 ), math.Rand( 0, 1 ), math.Rand( 0, 1 ) ) )
    else
        ply\SetPlayerColor( Vector( ply\GetInfo( "cl_playercolor" ) ) )
        ply\SetSkin( ply\GetInfoNum( "cl_playerskin", 0 ) )

        weaponColor = Vector( ply\GetInfo( "cl_weaponcolor" ) )
        if weaponColor\Length! < 0.001
            weaponColor = Vector( 0.001, 0.001, 0.001 )
        ply\SetWeaponColor( weaponColor )

        groups = string.Explode( " ", ply\GetInfo( "cl_playerbodygroups" ) or "" )
        for i = 0, ply\GetNumBodyGroups! - 1 do
            ply\SetBodygroup( i, tonumber( groups[ i + 1 ] ) or 0 )

    hook_Run( "TeamPlayerSpawn", ply, teamID )
    ply\SetupHands!

GM.OnEntityCreated = ( weapon ) =>
    unless weapon\IsWeapon!
        return

    timer.Simple( 0.025, ->
        unless weapon\IsValid!
            return

        if IsValid( weapon\GetOwner! )
            return

        if weapon\GetPos!\Length! <= 3
            weapon\Remove!
            return

        weapon\SetCollisionGroup( COLLISION_GROUP_WEAPON )

        phys = weapon\GetPhysicsObject!
        unless IsValid( phys ) and phys\IsMotionEnabled!
            return

        counter = 0
        for entity in *ents.FindInSphere( weapon\GetPos!, 32 )
            if entity\IsWeapon! and not IsValid( entity\GetOwner! )
                counter = counter + 1
                if counter >= 5
                    phys\EnableMotion( false )
                    return
    )

GM.PlayerDroppedWeapon = ( ply, weapon ) =>
    timerName = "JB_WeaponDrop #" .. weapon\EntIndex!
    timer.Create( timerName, 3, 1, ->
        timer.Remove( timerName )
        unless weapon\IsValid!
            return

        phys = weapon\GetPhysicsObject!
        unless IsValid( phys )
            return

        start = weapon\LocalToWorld( weapon\OBBCenter! )
        mins, maxs = weapon\GetCollisionBounds!

        tr = util.TraceHull( {
            start: start
            endpos: start + Vector( 0, 0, mins[ 3 ] - 2 )
            mask: MASK_SOLID_BRUSHONLY
            mins: mins
            maxs: maxs
        } )

        if tr.Hit
            weapon\SetCollisionGroup( COLLISION_GROUP_DEBRIS )
            phys\EnableMotion( false )
            return

        @PlayerDroppedWeapon( ply, weapon )
    )

GM.PlayerLoadout = ( ply, teamID ) =>
    if teamID == TEAM_PRISONER
        ply\GiveAmmo( 30, "ar2", true )
        ply\GiveAmmo( 45, "smg1", true )
        ply\GiveAmmo( 20, "Pistol", true )
        ply\GiveAmmo( 10, "Buckshot", true )
        if not ply\HasWeapon( "weapon_knife" ) and math.random( 1, 10 ) == 1
            ply\Give( "weapon_knife" )
    elseif teamID == TEAM_GUARD
        ply\GiveAmmo( 7, "357", true )
        ply\GiveAmmo( 60, "ar2", true )
        ply\GiveAmmo( 90, "smg1", true )
        ply\GiveAmmo( 40, "Pistol", true )
        ply\GiveAmmo( 20, "Buckshot", true )

    ply\Give( "jb_hands" )
    ply\SelectWeapon( "jb_hands" )

GM.PlayerSetModel = ( ply, teamID ) =>
    models = @PlayerModels[ teamID ]
    if teamID == TEAM_PRISONER
        models = models[ @FemalePrison and 1 or 2 ]

    requested = player_manager.TranslatePlayerModel( ply\GetInfo( "cl_playermodel" ) )
    if requested and #requested > 0
        for modelPath in *models
            if modelPath == requested
                ply\SetModel( modelPath )
                return

    ply\SetModel( table.Random( models ) )

GM.PlayerSetHandsModel = ( ply, hands ) =>
    info = player_manager.TranslatePlayerHands( player_manager.TranslateToPlayerModelName( ply\GetModel! ) )
    unless info
        return

    hands\SetModel( info.model )
    hands\SetSkin( info.matchBodySkin and ply\GetSkin! or info.skin )
    hands\SetBodyGroups( info.body )

GM.PlayerDeathThink = ( ply ) =>
    if @GameInProgress! and @PlayableTeams[ ply\Team! ]
        return
    ply\Spawn!

GM.IsSpawnpointSuitable = ( ply, entity, bMakeSuitable ) =>
    unless @PlayableTeams[ ply\Team! ]
        return true

    start = entity\GetPos!
    mins, maxs = ply\GetHull!

    tr = util.TraceHull( {
        start: start
        endpos: start
        mask: MASK_PLAYERSOLID
        filter: entity
        mins: mins
        maxs: maxs
    } )

    return not tr.Hit

GM.DoPlayerDeath = ( ply, attacker, dmginfo ) =>
    ply\CreateRagdoll()
    ply\AddDeaths( 1 )

GM.PlayerSilentDeath = ( ply ) =>
    teamID = ply\Team!
    if @PlayableTeams[ teamID ]
        hook_Run( "TeamPlayerDeath", ply, teamID )

GM.PlayerDeath = ( ply, inflictor, attacker ) =>
    teamID = ply\Team!
    if @PlayableTeams[ teamID ]
        hook_Run( "TeamPlayerDeath", ply, teamID )

    -- TODO: Write here death notifies

GM.EntityTakeDamage = ( entity, damageInfo ) =>
    if bit.band( damageInfo\GetDamageType!, DMG_NEVERGIB ) == DMG_NEVERGIB
        return

    switch entity\GetClass!
        when "prop_door_rotating"

            maxHealth = entity\GetMaxHealth!
            if maxHealth <= 1
                maxHealth = @DoorsHealth\GetInt!
                entity\SetHealth( maxHealth )
                entity\SetMaxHealth( maxHealth )

            health = entity\Health!
            if health < 1
                return true

            health = math.max( 0, health - damageInfo\GetDamage! )
            entity\SetHealth( health )

            if health > 1
                return true

            model = entity\GetModel!
            unless model and #model ~= 0 and util.IsValidModel( model )
                return true

            center = entity\OBBCenter!
            center[ 1 ] = 0
            center[ 2 ] = 0

            origin = entity\LocalToWorld( center )
            unless util.IsInWorld( origin )
                return true

            prop = ents.Create( "prop_physics" )
            prop\SetCollisionGroup( COLLISION_GROUP_WEAPON )
            prop\SetAngles( entity\GetAngles! )
            prop\SetSkin( entity\GetSkin! )
            prop\SetModel( model )
            prop\SetPos( origin )
            prop\Spawn()

            name = entity\GetName!
            if name ~= ""
                for portal in *ents.FindByClass( "func_areaportal" )
                    if portal\GetInternalVariable( "target" ) ~= name
                        continue

                    portal\SetSaveValue( "target", "" )
                    portal\Fire( "open" )

            prop\EmitSound( "physics/wood/wood_crate_break" .. math.random( 1, 5 ) .. ".wav", 70, math.random( 80, 120 ), 1, CHAN_STATIC, 0, 1 )
            entity\Remove!

            phys = prop\GetPhysicsObject!
            if IsValid( phys )
                phys\ApplyForceOffset( damageInfo\GetDamageForce!, damageInfo\GetDamagePosition! )

            origin = damageInfo\GetDamagePosition!
            fx = EffectData!
            fx\SetOrigin( origin )
            fx\SetMagnitude( 5 )
            fx\SetRadius( 5 )
            fx\SetScale( 2 )
            util.Effect( "Sparks", fx )
            util.ScreenShake( origin, 5, 10, 0.5, 150 )
            return true
        when "func_button"
            attacker = damageInfo\GetAttacker!
            if IsValid( attacker ) and attacker\IsPlayer!
                entity\Use( attacker, attacker )
            return true

GM.PlayerShouldTakeDamage = ( ply, attacker ) =>
    unless @PlayableTeams[ ply\Team! ]
        return false

    if @IsRoundPreparing!
        return false

    if @GameInProgress! and ply\IsGuard! and attacker\IsPlayer! and ply ~= attacker
        return attacker\IsPrisoner!

    return true

GM.FriendlyFire = ( ply, teamID ) =>
    return true

GM.GetFallDamage = ( ply, speed ) =>
    return math.max( 0, math.ceil( 0.2418 * speed - 141.75 ) )

GM.PlayerShouldTaunt = ( ply, act ) =>
    return @PlayableTeams[ ply\Team! ] and ply\Alive!

GM.AllowPlayerPickup = ( ply, entity ) =>
    unless @PlayableTeams[ ply\Team! ]
        return false

    weapon = ply\GetActiveWeapon!
    return IsValid( weapon ) and weapon\GetClass! == "jb_hands"

GM.PlayerCanPickupItem = ( ply, entity ) =>
    return @PlayableTeams[ ply\Team! ]

GM.PlayerCanPickupWeapon = ( ply, weapon ) =>
    if ply.Loadout
        return true
    return false

GM.PlayerNoClip = ( ply, desiredState ) =>
    unless desiredState
        return true

    unless @PlayableTeams[ ply\Team! ]
        return false

    return ply\IsSuperAdmin!

GM.CanPlayerSuicide = ( ply ) =>
    if @IsRoundPreparing!
        return false
    return @PlayableTeams[ ply\Team! ]

GM.PlayerSwitchFlashlight = ( ply ) =>
    return ply\IsGuard! or ply\CanUseFlashlight!

GM.PlayerDeathSound = ( ply ) =>
    unless @IsRoundRunning!
        return true
    return ply\IsPrisoner!

GM.PlayerUse = ( ply, entity ) =>
    unless @PlayableTeams[ ply\Team! ]
        return false

    curTime, lastUse = CurTime!, ply.LastUse or 0
    ply.LastUse = curTime

    if ( curTime - lastUse ) <= 0.25
        return

    if entity\IsWeapon!
        if ply\HasWeapon( entity\GetClass! )
            clip1, clip1Type = entity\Clip1!, entity\GetPrimaryAmmoType!
            if clip1 > 0 and clip1Type >= 0
                ply\GiveAmmo( clip1, clip1Type, false )
                entity\SetClip1( 0 )

            clip2, clip2Type = entity\Clip2!, entity\GetSecondaryAmmoType!
            if clip2 > 0 and clip2Type >= 0
                ply\GiveAmmo( clip2, clip2Type, false )
                entity\SetClip2( 0 )

        else
            ply\PickupWeapon( entity, false )

        return false

    weapon = ply\GetActiveWeapon!
    if IsValid( weapon ) and weapon\GetHoldType! == "fist" and entity\IsPlayer!
        velocity = ply\GetVelocity!\GetNormalized! * 16
        entity\SetVelocity( velocity )
        ply\SetVelocity( -velocity )
        return false
    return true

GM.PlayerCanSeePlayersChat = ( str, isTeam, listener, speaker ) =>
    unless @GameInProgress!
        return true

    if @AllTalk\GetInt! > 2
        return true

    unless IsValid( speaker )
        return true

    listenerAlive, speakerAlive = listener\Alive!, speaker\Alive!
    if not listenerAlive and not speakerAlive
        return true

    listenerTeam, speakerTeam = listener\Team!, speaker\Team!
    if not @PlayableTeams[ listenerTeam ] and not speakerAlive
        return true

    if not @PlayableTeams[ speakerTeam ] and not listenerAlive
        return true

    if isTeam and speakerTeam == listenerTeam
        return true

    return false

GM.PlayerCanHearPlayersVoice = ( listener, speaker ) =>
    unless @GameInProgress!
        return true, false

    if @AllTalk\GetInt! > 2
        return true, false

    listenerAlive, speakerAlive = listener\Alive!, speaker\Alive!
    if not listenerAlive and not speakerAlive
        return true, false

    listenerTeam, speakerTeam = listener\Team!, speaker\Team!
    if not @PlayableTeams[ listenerTeam ] and not speakerAlive
        return true, false

    if not @PlayableTeams[ speakerTeam ] and not listenerAlive
        return true, false

    speakerPosition = speaker\EyePos!
    if speakerPosition\DistToSqr( listener\EyePos! ) <= @VoiceChatDistance
        rf = RecipientFilter!
        rf\AddPAS( speakerPosition )
        for ply in *rf\GetPlayers!
            if ply == listener
                return true, true

    return false, false

GM.GetTeamAliveCount = ( teamID ) =>
    alive = 0
    for ply in *team.GetPlayers( teamID )
        if ply\Alive!
            alive += 1
    return alive

GM.PlayerRequestTeam = ( ply, teamID ) =>
    unless team.Joinable( teamID )
        return

    if ply\Team! == teamID
        return

    if @PlayableTeams[ teamID ] and teamID ~= TEAM_PRISONER
        guardCount = @GetTeamAliveCount( TEAM_GUARD )
        unless guardCount == 0 or ( guardCount / @GetTeamAliveCount( TEAM_PRISONER ) ) < @GuardsDiff
            -- TODO: here chat message
            return

    if ply\Alive!
        if @PlayableTeams[ ply\Team! ]
            ply\Kill!
        else
            ply\KillSilent!

    ply\SetTeam( teamID )

concommand.Add( "drop", ( ply ) ->
    dropWeapon = ply\GetActiveWeapon!
    unless IsValid( dropWeapon )
        return

    model = dropWeapon\GetWeaponWorldModel!
    unless model and util.IsValidModel( model )
        return

    ply\DropWeapon( dropWeapon )

    maxWeight, nextWeapon = nil, nil
    for weapon in *ply\GetWeapons!
        weight = weapon\GetWeight!

        if not maxWeight or maxWeight <= weight
            nextWeapon = weapon
            maxWeight = weight

    unless IsValid( nextWeapon )
        return

    ply\SelectWeapon( nextWeapon\GetClass! )
)

GM.InitPostEntity = =>
    @SetRoundState( "waiting" )

GM.SetRoundState = ( state ) =>
    oldState = @GetRoundState!
    SetGlobal2String( "round-state", state )
    hook_Run( "RoundStateChanged", oldState, state )

GM.SetWinningTeam = ( teamID ) =>
    SetGlobal2Int( "winning-team", teamID )

GM.CanChangeRoundState = =>
    return @GetNextRoundStateTime! <= CurTime!

GM.NextRoundStateTime = =>
    SetGlobal2Int( "next-round-state", CurTime! + @Preparing\GetInt! )

GM.Think = =>
    unless @CanChangeRoundState!
        return

    switch @GetRoundState!
        when "preparing"
            @SetRoundState( "running" )
        when "ended"
            @SetRoundState( "waiting" )

GM.SelectBestTeam = ( ply ) =>
    guardCount = @GetTeamAliveCount( TEAM_GUARD )
    if guardCount == 0 or ( guardCount / @GetTeamAliveCount( TEAM_PRISONER ) ) < @GuardsDiff
        ply\SetTeam( TEAM_GUARD )
    else
        ply\SetTeam( TEAM_PRISONER )

GM.RoundStateChanged = ( old, new ) =>
    switch ( new )
        when "waiting"
            for ply in *player.GetAll!
                if ply\IsBot!
                    @PlayerRequestTeam( ply, TEAM_PRISONER )
                elseif @PlayableTeams[ ply\Team! ]
                    ply\KillSilent!
    		timer.Simple( 0, game.CleanUpMap )

        when "preparing"
            @FemalePrison = math.random( 1, 10 ) == 1
            for ply in *player.GetAll!
                if ply\IsBot!
                    @SelectBestTeam( ply )

                if @PlayableTeams[ ply\Team! ]
                    ply\Spawn!
    		timer.Simple( 0, game.CleanUpMap )

        when "running"
            guardCount, prisonerCount = @GetTeamAliveCount( TEAM_GUARD ), @GetTeamAliveCount( TEAM_PRISONER )
            totalCount = guardCount + prisonerCount

            while ( guardCount / prisonerCount ) > @GuardsDiff and totalCount > ( ( 1 / @GuardsDiff ) + guardCount )
                for i = 1, guardCount
                    guard = table.Random( team.GetPlayers( TEAM_GUARD ) )
                    if guard\IsValid!
                        guard\SetTeam( TEAM_PRISONER )
                        guard\Spawn!
                        break
                guardCount, prisonerCount = @GetTeamAliveCount( TEAM_GUARD ), @GetTeamAliveCount( TEAM_PRISONER )
                totalCount = guardCount + prisonerCount

            if guardCount == 0 or prisonerCount == 0
                @SetRoundState( "waiting" )
                return

            for ply in *player.GetAll!
                if ply\IsBot!
                    @SelectBestTeam( ply )
                    ply\Spawn!
                elseif @PlayableTeams[ ply\Team! ] and not ply\Alive!
                    ply\Spawn!

        when "ended"
            guardCount, prisonerCount = @GetTeamAliveCount( TEAM_GUARD ), @GetTeamAliveCount( TEAM_PRISONER )
            if guardCount > prisonerCount
                team.AddScore( TEAM_GUARD, 1 )
                @SetWinningTeam( TEAM_GUARD )
            elseif guardCount < prisonerCount
                team.AddScore( TEAM_PRISONER, 1 )
                @SetWinningTeam( TEAM_PRISONER )
            else
                @SetWinningTeam( 0 )

GM.TeamPlayerSpawn = ( ply, teamID ) =>
    if @IsWaitingPlayers! and @GetTeamAliveCount( TEAM_GUARD ) > 0 and @GetTeamAliveCount( TEAM_PRISONER ) > 0
        @SetRoundState( "preparing" )
        @NextRoundStateTime!

GM.TeamPlayerDeath = ( ply, teamID ) =>
    if @IsRoundRunning! and ( @GetTeamAliveCount( TEAM_GUARD ) == 0 or @GetTeamAliveCount( TEAM_PRISONER ) == 0 )
        @SetRoundState( "ended" )
        @NextRoundStateTime!
    ply\Spectate( OBS_MODE_ROAMING )

GM.PlayerDisconnected = ( ply ) =>
    if @IsRoundRunning! and ( team.NumPlayers( TEAM_GUARD ) == 0 or team.NumPlayers( TEAM_PRISONER ) == 0 )
        @SetRoundState( "ended" )
        @NextRoundStateTime!

concommand.Add( "changeteam", ( ply, _, args ) ->
    hook_Run( "PlayerRequestTeam", ply, tonumber( args[ 1 ] ) )
)