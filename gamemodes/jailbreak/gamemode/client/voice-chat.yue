Jailbreak = Jailbreak

:ceil, :floor, :log, :max, :min, :Clamp = math
:dark_grey, :black, :white = Jailbreak.Colors
:DrawRect, :SetDrawColor = surface
IsValid = IsValid
:VMin = Jailbreak
select = select
NULL = NULL
:Run = hook

Jailbreak.Font( "Jailbreak::Voice Chat", "Roboto Mono Medium", 2 )

-- Voice Chat Notify
do

    LEFT, BOTTOM, FILL = LEFT, BOTTOM, FILL
    FrameTime = FrameTime

    PANEL = {}

    PANEL.Init = =>
        @SetAlpha( 0 )
        @Dock( BOTTOM )
        @Player = NULL

        avatar = @Add( "AvatarImage" )
        @Avatar = avatar

        avatar\Dock( LEFT )

        label = @Add( "DLabel" )
        @Label = label

        label\SetExpensiveShadow( 1, dark_grey )
        label\SetFont( "Jailbreak::Voice Chat" )
        label\SetContentAlignment( 4 )
        label\SetTextColor( white )
        label\Dock( FILL )

        @VoiceData = {}
        @NextVoiceData = 0
        @VoiceDataLength = 0

    PANEL.PerformLayout = ( width ) =>
        height, padding = VMin( 4 ), VMin( 0.5 )
        @VoiceDataLength = ceil( max( width, 4 ) / padding )
        @DockPadding( padding, padding, padding, padding )
        @DockMargin( 0, padding, 0, 0 )

        @Label\DockMargin( padding, 0, 0, 0 )
        height = max( height, select( 2, @Label\GetTextSize! ) + padding * 2 )

        avatar = @Avatar
        avatarHeight = avatar\GetTall!
        avatar\SetWide( avatarHeight )

        ply = @Player
        if IsValid( ply )
            avatar\SetPlayer( ply, Clamp( 2 ^ floor( log( ceil( avatarHeight ), 2 ) ), 16, 512 ) )

        @SetTall( height )

    PANEL.Setup = ( ply ) =>
        unless ply\IsValid!
            @Remove!
            return

        label = @Label
        if label and label\IsValid!
            label\SetTextColor( ply\GetModelColor! )
            label\SetText( ply\Nick! )

        @Player = ply
        @InvalidateLayout!

    do

        :remove = table

        PANEL.Think = =>
            if @NextVoiceData < CurTime!
                ply = @Player
                if IsValid( ply )
                    voiceData = @VoiceData
                    length = #voiceData

                    if length > @VoiceDataLength
                        remove( voiceData, 1 )

                    voiceData[ length + 1 ] = max( 0.05, ply\VoiceFraction! )
                    @NextVoiceData = CurTime! + 0.025

            animationType = @AnimationType
            if animationType ~= nil
                if animationType
                    alpha = @GetAlpha!
                    if alpha > 0
                        @SetAlpha( max( 0, @GetAlpha! - 255 * FrameTime! * 2 ) )
                    else
                        @AnimationType = nil
                        if @IsVisible!
                            @Hide!

                else

                    alpha = @GetAlpha!
                    if alpha < 255
                        @SetAlpha( min( @GetAlpha! + 255 * FrameTime! * 2, 255 ) )
                    else
                        @AnimationType = nil

    PANEL.FadeIn = =>
        @AnimationType = true

    PANEL.FadeOut = =>
        @AnimationType = false
        unless @IsVisible!
            @Show!

    PANEL.IsInAnimation = =>
        return @AnimationType ~= nil

    PANEL.Paint = ( width, height ) =>
        for index = 1, @VoiceDataLength
            volume = @VoiceData[ index ]
            if volume ~= nil
                r, g, b = 255, 255, 255

                ply = @Player
                if IsValid( ply ) and ply\Alive!
                    r, g, b = ply\GetTeamColorUpacked!

                SetDrawColor( r, g, b, floor( volume * 255 ) )

                leftPadding, topPadding = @GetDockPadding!
                voiceDataHeight = ceil( ( height - topPadding ) * volume )
                DrawRect( ( index - 1 ) * leftPadding, height - voiceDataHeight, leftPadding, voiceDataHeight )

        SetDrawColor( black.r, black.g, black.b, 50 )
        DrawRect( 0, 0, width - 1, height - 1 )

        SetDrawColor( black.r, black.g, black.b, 120 )
        DrawRect( 0, 0, width + 2, height + 2 )

        SetDrawColor( dark_grey.r, dark_grey.g, dark_grey.b, 200 )
        DrawRect( 0, 0, width, height )

    vgui.Register( "Jailbreak::VoiceNotify", PANEL, "Panel" )

-- Voice Chat Panel
do

    PANEL = {}

    PANEL.Init = =>
        @SetZPos( 1000 )
        @Dock( RIGHT )

    PANEL.GetVoicePanel = ( ply ) =>
        for panel in *@GetChildren!
            if panel.Player == ply
                return panel

    PANEL.StartVoice = ( ply ) =>
        panel = @GetVoicePanel( ply )
        unless IsValid( panel )
            panel = @Add( "Jailbreak::VoiceNotify" )

        panel\Setup( ply )
        panel\FadeOut!

        @InvalidateLayout!

    PANEL.EndVoice = ( ply ) =>
        panel = @GetVoicePanel( ply )
        if IsValid( panel )
            panel\FadeIn!

    PANEL.Think = =>
        for panel in *@GetChildren!
            unless IsValid( panel.Player )
                if panel\GetAlpha! == 0
                    panel\Remove!
                elseif not panel\IsInAnimation!
                    panel\FadeIn!

    PANEL.PerformLayout = =>
        margin = VMin( 1 )
        @DockMargin( 0, margin, margin, margin )
        @SetWide( Jailbreak.ScreenWidth / 6 )

    vgui.Register( "Jailbreak::VoiceChat", PANEL, "Panel" )

do

    :VoiceChatNotifications = Jailbreak

    GM.PlayerStartVoice = ( ply ) =>
        if ply\IsLocalPlayer!
            Run( "LocalPlayerVoice", ply, true )
            return true

        voiceChat = Jailbreak.VoiceChat
        unless VoiceChatNotifications\GetBool!
            if IsValid( voiceChat )
                voiceChat\Remove!

            return

        unless IsValid( voiceChat )
            voiceChat = vgui.Create( "Jailbreak::VoiceChat", GetHUDPanel! )
            Jailbreak.VoiceChat = voiceChat

        voiceChat\StartVoice( ply )
        return true

GM.PlayerEndVoice = ( ply ) =>
    if ply\IsLocalPlayer!
        Run( "LocalPlayerVoice", ply, false )
        return

    voiceChat = Jailbreak.VoiceChat
    if IsValid( voiceChat )
        voiceChat\EndVoice( ply )

do

    :SetVoiceVolumeScale = FindMetaTable( "Player" )
    :ReadEntity, :ReadFloat, :ReadUInt = net

    net.Receive "JB::Communication", ->
        for i = 1, ReadUInt( 10 )
            ply, volume = ReadEntity!, ReadFloat!
            if ply\IsValid!
                SetVoiceVolumeScale( ply, volume )

do

    :VoiceFlexLess, :VoiceForceFlexLess = Jailbreak
    :abs, :sin, :Rand = math
    angle_zero = angle_zero
    LerpAngle = LerpAngle
    :find = string
    Angle = Angle

    patterns = {
        "right_corner_puller"
    	"left_corner_puller"

        "right_cheek_raiser"
        "left_cheek_raiser"

        "right_part"
        "left_part"

        "jaw_drop"

        "right_mouth_drop"
        "left_mouth_drop"

        "smile"
        "lower_lip"

        -- "corner_depressor"
    }

    mults = {
        right_cheek_raiser: 0.25
        left_cheek_raiser: 0.25
        -- right_mouth_drop: 0.5
        -- left_mouth_drop: 0.5
        lower_lip: 0.05
        jaw_drop: 0.5
        smile: 0.05
    }

    cache = {}

    GM.MouthMoveAnimation = ( ply ) =>
        flexes = cache[ ply\GetModel! ]
        if flexes == nil
            flexes = {}
            for flex = 0, ply\GetFlexNum!
                flexName, found = ply\GetFlexName( flex ), false
                for index = 1, #patterns
                    pattern = patterns[ index ]
                    if flexName == pattern or find( flexName, pattern, 1, false ) ~= nil
                        found = true
                        break

                if found
                    flexes[] = { flex, flexName, ply\GetFlexBounds( flex ) }

            if #flexes == 0
                flexes = false

            cache[ ply\GetModel! ] = flexes

        if flexes and not VoiceForceFlexLess\GetBool!
            fraction = ply\VoiceFraction!
            ply\SetFlexScale( 2 )

            flexCount = #flexes
            for i = 1, flexCount
                if fraction > 0
                    data = flexes[ i ]
                    ply\SetFlexWeight( data[ 1 ], Clamp( abs( sin( data[ 1 ] * ( 1 / flexCount ) + CurTime! ) ) * fraction + fraction, data[ 3 ], data[ 4 ] ) * ( mults[ data[ 2 ] ] or 1 ) )
                else
                    ply\SetFlexWeight( flexes[ i ][ 1 ], 0 )

            return

        value = VoiceFlexLess\GetInt!
        if value == 0
            return

        fraction, angles = ply\VoiceFraction!, angle_zero
        if fraction ~= 0
            if value <= 2
                angles = Angle( Rand( -45, 45 ), Rand( -90, 90 ), 0 ) * fraction

            elseif value <= 5
                angle = min( 360, value * 72 )
                angles = Angle( Rand( -angle, angle ), Rand( -angle, angle ), 0 ) * fraction

            else
                angle = min( 360, value * 36 )
                angles = Angle( Rand( -angle, angle ), Rand( -angle, angle ), Rand( -angle, angle ) ) * fraction

        angles = LerpAngle( 0.25, ply.MouthLessAngles or angle_zero, angles )
        ply.MouthLessAngles = angles

        if value > 1
            ply\ManipulateBoneAngles( 0, angles, false )
        else
            boneID = ply\LookupBone( "ValveBiped.Bip01_Head1" )
            if boneID and boneID >= 0
                ply\ManipulateBoneAngles( boneID, angles, false )
            else
                ply\ManipulateBoneAngles( 0, angles, false )
