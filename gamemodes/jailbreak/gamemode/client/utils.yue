Jailbreak = Jailbreak
:Simple = timer
:max = math
:Run = hook

do

    :String = cvars

    cvars.AddChangeCallback( "gmod_language", ( _, __, value ) ->
        timer.Create "Jailbreak::LanguageChanged", 0.025, 1, ->
            Run( "LanguageChanged", String( "gmod_language", "en" ), value )
    "Jailbreak::LanguageChanged" )

do

    RunConsoleCommand = RunConsoleCommand

    Jailbreak.ChangeTeam = ( teamID ) ->
        RunConsoleCommand( "changeteam", teamID )

do

    :sub, :gsub = string
    :GetPhrase = language

    filter = ( placeholder ) ->
        fulltext = GetPhrase( placeholder )
        if fulltext == placeholder and sub( placeholder, 1, 3 ) == "jb."
            return GetPhrase( sub( placeholder, 4 ) )

        return fulltext

    Jailbreak.GetPhrase = filter

    Jailbreak.Translate = ( str ) ->
        return gsub( str, "#([%w%.-_]+)", filter )

do

    ScrW, ScrH = ScrW, ScrH
    :min, :ceil = math

    width, height = ScrW!, ScrH!
    vmin, vmax = min( width, height ) / 100, max( width, height ) / 100

    Jailbreak.ScreenWidth, Jailbreak.ScreenHeight = width, height
    Jailbreak.ScreenCenterX, Jailbreak.ScreenCenterY = width / 2, height / 2

    hook.Add "OnScreenSizeChanged", "Jailbreak::OnScreenSizeChanged", ->
        width, height = ScrW!, ScrH!
        vmin, vmax = min( width, height ) / 100, max( width, height ) / 100

        Jailbreak.ScreenWidth, Jailbreak.ScreenHeight = width, height
        Jailbreak.ScreenCenterX, Jailbreak.ScreenCenterY = width / 2, height / 2
        Run( "ScreenResolutionChanged", width, height )

    Jailbreak.VMin = ( number ) ->
        if number ~= nil
            return ceil( vmin * number )

        return vmin

    Jailbreak.VMax = ( number ) ->
        if number ~= nil
            return ceil( vmax * number )

        return vmax

do

    fonts = Jailbreak.Fonts
    unless istable( fonts )
        fonts = {}
        Jailbreak.Fonts = fonts

    :CreateFont = surface
    :VMin = Jailbreak
    :remove = table

    fontData = {
        extended: true
        weight: 500
        blursize: 0
        scanlines: 0
        antialias: true
        underline: false
        italic: false
        strikeout: false
        symbol: false
        rotary: false
        shadow: false
        additive: false
        outline: false
    }

    Jailbreak.Font = ( fontName, font, size ) ->
        fontData.font, fontData.size = font, VMin( size )
        for index = 1, #fonts
            if fonts[ index ].fontName == fontName
                remove( fonts, index )
                break

        fonts[] = {
            :fontName
            :font
            :size
        }

        CreateFont fontName, fontData

    hook.Add "ScreenResolutionChanged", "Jailbreak::Fonts" , ->
        for data in *fonts
            fontData.font, fontData.size = data.font, VMin( data.size )
            CreateFont data.fontName, fontData

GM.PerformPlayerVoice = ( ply ) =>
    voiceVolume = ply\IsSpeaking! and ply\VoiceVolume! or 0

    lastVoiceVolume = ply.m_LastVoiceVolume
    unless lastVoiceVolume
        lastVoiceVolume = voiceVolume

    if lastVoiceVolume > 0
        voiceVolume = lastVoiceVolume + ( voiceVolume - lastVoiceVolume ) / 4
        if voiceVolume < 0.01
            voiceVolume = 0

    ply.m_LastVoiceVolume = voiceVolume

    maxVoiceVolume = ply.m_MaxVoiceVolume
    if not maxVoiceVolume or maxVoiceVolume < voiceVolume
        maxVoiceVolume = voiceVolume
        ply.m_MaxVoiceVolume = maxVoiceVolume

    if maxVoiceVolume > 0 and voiceVolume > 0
        ply.m_bVoiceFraction = voiceVolume / maxVoiceVolume
        return

    ply.m_bVoiceFraction = 0

ENTITY = FindMetaTable( "Entity" )

do

    PLAYER = FindMetaTable( "Player" )

    do

        Player = Player

        gameevent.Listen( "player_spawn" )

        hook.Add "player_spawn", "Jailbreak::SpawnEffect", ( data ) ->
            ply = Player( data.userid )
            unless ply and ply\IsValid!
                return

            pl = Jailbreak.Player
            if pl\IsValid!
                ply.m_bSpawnTime = CurTime! + pl\Ping! / 1000
            else
                ply.m_bSpawnTime = CurTime! + 0.25

    do

        :GetNW2Int = ENTITY

        PLAYER.GetSpawnTime = =>
            return @m_bSpawnTime or GetNW2Int( @, "spawn-time" )

    PLAYER.VoiceFraction = =>
        return @m_bVoiceFraction or 0

    do

        isfunction = isfunction

        PLAYER.AnimRestartNetworkedGesture = ( slot, activity, autokill, finished ) =>
            sequenceID = @SelectWeightedSequence( activity )
            if sequenceID < 0
                return

            if isfunction( finished )
                Simple @SequenceDuration( sequenceID ), ->
                    if @IsValid!
                        finished( @ )

            @AnimRestartGesture( slot, activity, autokill )

do

    :EntIndex = ENTITY

    -- Returns true if door entity is locked
    ENTITY.IsDoorLocked = =>
        return @GetNW2Bool( "m_bLocked" )

    -- Returns door entity state
    ENTITY.GetDoorState = =>
        return @GetNW2Int( "m_eDoorState" )

    -- Returns true if entity is local player
    ENTITY.IsLocalPlayer = =>
        index = Jailbreak.PlayerIndex
        unless index
            return true

        return EntIndex( @ ) == index

do

    shopItems = Jailbreak.ShopItems
    unless shopItems
        shopItems = {}
        Jailbreak.ShopItems = shopItems

    :ReadString, :ReadUInt, :ReadBool = net
    :Empty = table

    net.Receive "Jailbreak::Shop", ->
        table.Empty( shopItems )

        for index = 1, ReadUInt( 16 )
            name = ReadString!
            shopItems[ index ] = {
                name: name
                title: "#jb." .. name
                model: ReadString!
                price: ReadUInt( 16 )
                skin: ReadUInt( 8 )
                bodygroups: ReadString!
            }

        Run( "ShopItems", shopItems )

-- Pure performance
do

    :GetPlayerColor = FindMetaTable( "Entity" )
    :SetVector = FindMetaTable( "IMaterial" )

    matproxy.Add {
        name: "PlayerColor"
        init: ( _, values ) =>
            @ResultTo = values.resultvar

        bind: ( material, entity ) =>
            SetVector( material, @ResultTo, GetPlayerColor( entity ) )

    }
